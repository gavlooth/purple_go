        -:    0:Source:test_scc.c
        -:    0:Graph:./run_tests_cov-test_main.gcno
        -:    0:Data:./run_tests_cov-test_main.gcda
        -:    0:Runs:1
        -:    1:/* test_scc.c - SCC (Strongly Connected Components) detection tests */
        -:    2:#include "test_framework.h"
        -:    3:
        -:    4:/* ========== SCC Registry Tests ========== */
        -:    5:
function test_scc_registry_init called 1 returned 100% blocks executed 50%
        1:    6:void test_scc_registry_init(void) {
        -:    7:    /* Registry should start empty */
       1*:    8:    ASSERT_EQ(SCC_REGISTRY.next_id, 0);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:    9:    PASS();
call    0 returned 1
        -:   10:}
        -:   11:
function test_create_scc called 1 returned 100% blocks executed 45%
        1:   12:void test_create_scc(void) {
        1:   13:    SCC* scc = create_scc();
call    0 returned 1
       1*:   14:    ASSERT_NOT_NULL(scc);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:   15:    ASSERT_EQ(scc->member_count, 0);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:   16:    ASSERT_EQ(scc->ref_count, 1);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:   17:    ASSERT_EQ(scc->frozen, 0);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:   18:    freeze_scc(scc);
call    0 returned 1
        1:   19:    release_scc(scc);
call    0 returned 1
        1:   20:    PASS();
call    0 returned 1
        -:   21:}
        -:   22:
function test_create_multiple_sccs called 1 returned 100% blocks executed 61%
        1:   23:void test_create_multiple_sccs(void) {
        1:   24:    int base_id = SCC_REGISTRY.next_id;
        1:   25:    SCC* scc1 = create_scc();
call    0 returned 1
        1:   26:    SCC* scc2 = create_scc();
call    0 returned 1
        1:   27:    SCC* scc3 = create_scc();
call    0 returned 1
       1*:   28:    ASSERT_EQ(scc1->id, base_id);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:   29:    ASSERT_EQ(scc2->id, base_id + 1);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:   30:    ASSERT_EQ(scc3->id, base_id + 2);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:   31:    freeze_scc(scc1);
call    0 returned 1
        1:   32:    freeze_scc(scc2);
call    0 returned 1
        1:   33:    freeze_scc(scc3);
call    0 returned 1
        1:   34:    release_scc(scc1);
call    0 returned 1
        1:   35:    release_scc(scc2);
call    0 returned 1
        1:   36:    release_scc(scc3);
call    0 returned 1
        1:   37:    PASS();
call    0 returned 1
        -:   38:}
        -:   39:
        -:   40:/* ========== SCC Member Management Tests ========== */
        -:   41:
function test_scc_add_member called 1 returned 100% blocks executed 53%
        1:   42:void test_scc_add_member(void) {
        1:   43:    SCC* scc = create_scc();
call    0 returned 1
        1:   44:    Obj* obj = mk_int(42);
call    0 returned 1
        1:   45:    scc_add_member(scc, obj);
call    0 returned 1
       1*:   46:    ASSERT_EQ(scc->member_count, 1);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:   47:    ASSERT_EQ(scc->members[0], obj);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:   48:    ASSERT_EQ(obj->scc_id, scc->id);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:   49:    freeze_scc(scc);
call    0 returned 1
        1:   50:    release_scc(scc); /* frees members */
call    0 returned 1
        1:   51:    PASS();
call    0 returned 1
        -:   52:}
        -:   53:
function test_scc_add_multiple_members called 1 returned 100% blocks executed 63%
        1:   54:void test_scc_add_multiple_members(void) {
        1:   55:    SCC* scc = create_scc();
call    0 returned 1
        -:   56:    Obj* objs[10];
       11:   57:    for (int i = 0; i < 10; i++) {
branch  0 taken 10
branch  1 taken 1 (fallthrough)
       10:   58:        objs[i] = mk_int(i);
call    0 returned 10
       10:   59:        scc_add_member(scc, objs[i]);
call    0 returned 10
        -:   60:    }
       1*:   61:    ASSERT_EQ(scc->member_count, 10);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       11:   62:    for (int i = 0; i < 10; i++) {
branch  0 taken 10
branch  1 taken 1 (fallthrough)
      10*:   63:        ASSERT_EQ(scc->members[i], objs[i]);
branch  0 taken 0 (fallthrough)
branch  1 taken 10
call    2 never executed
      10*:   64:        ASSERT_EQ(objs[i]->scc_id, scc->id);
branch  0 taken 0 (fallthrough)
branch  1 taken 10
call    2 never executed
        -:   65:    }
        1:   66:    freeze_scc(scc);
call    0 returned 1
        1:   67:    release_scc(scc); /* frees members */
call    0 returned 1
        1:   68:    PASS();
call    0 returned 1
        -:   69:}
        -:   70:
function test_scc_add_member_null_scc called 1 returned 100% blocks executed 100%
        1:   71:void test_scc_add_member_null_scc(void) {
        1:   72:    Obj* obj = mk_int(42);
call    0 returned 1
        1:   73:    scc_add_member(NULL, obj);  /* Should not crash */
call    0 returned 1
        1:   74:    dec_ref(obj);
call    0 returned 1
        1:   75:    PASS();
call    0 returned 1
        1:   76:}
        -:   77:
function test_scc_add_member_null_obj called 1 returned 100% blocks executed 70%
        1:   78:void test_scc_add_member_null_obj(void) {
        1:   79:    SCC* scc = create_scc();
call    0 returned 1
        1:   80:    scc_add_member(scc, NULL);  /* Should not crash */
call    0 returned 1
       1*:   81:    ASSERT_EQ(scc->member_count, 0);  /* Should not add */
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:   82:    freeze_scc(scc);
call    0 returned 1
        1:   83:    release_scc(scc);
call    0 returned 1
        1:   84:    PASS();
call    0 returned 1
        -:   85:}
        -:   86:
        -:   87:/* ========== SCC Freeze Tests ========== */
        -:   88:
function test_freeze_scc called 1 returned 100% blocks executed 54%
        1:   89:void test_freeze_scc(void) {
        1:   90:    SCC* scc = create_scc();
call    0 returned 1
       1*:   91:    ASSERT_EQ(scc->frozen, 0);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:   92:    freeze_scc(scc);
call    0 returned 1
       1*:   93:    ASSERT_EQ(scc->frozen, 1);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:   94:    release_scc(scc);
call    0 returned 1
        1:   95:    PASS();
call    0 returned 1
        -:   96:}
        -:   97:
function test_freeze_scc_null called 1 returned 100% blocks executed 100%
        1:   98:void test_freeze_scc_null(void) {
        1:   99:    freeze_scc(NULL);  /* Should not crash */
call    0 returned 1
        1:  100:    PASS();
call    0 returned 1
        1:  101:}
        -:  102:
        -:  103:/* ========== SCC Lookup Tests ========== */
        -:  104:
function test_find_scc called 1 returned 100% blocks executed 70%
        1:  105:void test_find_scc(void) {
        1:  106:    SCC* scc = create_scc();
call    0 returned 1
        1:  107:    int id = scc->id;
        1:  108:    SCC* found = find_scc(id);
call    0 returned 1
       1*:  109:    ASSERT_EQ(found, scc);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:  110:    freeze_scc(scc);
call    0 returned 1
        1:  111:    release_scc(scc);
call    0 returned 1
        1:  112:    PASS();
call    0 returned 1
        -:  113:}
        -:  114:
function test_find_scc_not_found called 1 returned 100% blocks executed 67%
        1:  115:void test_find_scc_not_found(void) {
        1:  116:    SCC* found = find_scc(-999);  /* Non-existent ID */
call    0 returned 1
       1*:  117:    ASSERT_NULL(found);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:  118:    PASS();
call    0 returned 1
        -:  119:}
        -:  120:
        -:  121:/* ========== SCC Reference Counting Tests ========== */
        -:  122:
function test_release_scc_single_ref called 1 returned 100% blocks executed 73%
        1:  123:void test_release_scc_single_ref(void) {
        1:  124:    SCC* scc = create_scc();
call    0 returned 1
        1:  125:    Obj* obj = mk_int(42);
call    0 returned 1
        1:  126:    scc_add_member(scc, obj);
call    0 returned 1
        1:  127:    freeze_scc(scc);
call    0 returned 1
       1*:  128:    ASSERT_EQ(scc->ref_count, 1);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:  129:    release_scc(scc);  /* Should free everything */
call    0 returned 1
        1:  130:    PASS();
call    0 returned 1
        -:  131:}
        -:  132:
function test_release_scc_null called 1 returned 100% blocks executed 100%
        1:  133:void test_release_scc_null(void) {
        1:  134:    release_scc(NULL);  /* Should not crash */
call    0 returned 1
        1:  135:    PASS();
call    0 returned 1
        1:  136:}
        -:  137:
function test_release_scc_not_frozen called 1 returned 100% blocks executed 100%
        1:  138:void test_release_scc_not_frozen(void) {
        1:  139:    SCC* scc = create_scc();
call    0 returned 1
        1:  140:    Obj* obj = mk_int(42);
call    0 returned 1
        1:  141:    scc_add_member(scc, obj);
call    0 returned 1
        -:  142:    /* Don't freeze */
        1:  143:    scc->ref_count = 0;
        1:  144:    release_scc(scc);  /* Should not free members because not frozen */
call    0 returned 1
        -:  145:    /* Reset refcount so cleanup can proceed */
        1:  146:    scc->ref_count = 1;
        1:  147:    freeze_scc(scc);
call    0 returned 1
        1:  148:    release_scc(scc);  /* cleanup SCC */
call    0 returned 1
        1:  149:    PASS();
call    0 returned 1
        1:  150:}
        -:  151:
        -:  152:/* ========== release_with_scc Tests ========== */
        -:  153:
function test_release_with_scc_member called 1 returned 100% blocks executed 100%
        1:  154:void test_release_with_scc_member(void) {
        1:  155:    SCC* scc = create_scc();
call    0 returned 1
        1:  156:    Obj* obj = mk_int(42);
call    0 returned 1
        1:  157:    inc_ref(obj);  /* Extra ref for SCC */
call    0 returned 1
        1:  158:    scc_add_member(scc, obj);
call    0 returned 1
        1:  159:    freeze_scc(scc);
call    0 returned 1
        1:  160:    release_with_scc(obj);  /* Should release via SCC */
call    0 returned 1
        -:  161:    /* obj may be freed by release_with_scc, don't dec_ref again */
        1:  162:    PASS();
call    0 returned 1
        1:  163:}
        -:  164:
function test_release_with_scc_non_member called 1 returned 100% blocks executed 100%
        1:  165:void test_release_with_scc_non_member(void) {
        1:  166:    Obj* obj = mk_int(42);
call    0 returned 1
        1:  167:    release_with_scc(obj);  /* Should fall back to dec_ref */
call    0 returned 1
        1:  168:    PASS();
call    0 returned 1
        1:  169:}
        -:  170:
function test_release_with_scc_null called 1 returned 100% blocks executed 100%
        1:  171:void test_release_with_scc_null(void) {
        1:  172:    release_with_scc(NULL);  /* Should not crash */
call    0 returned 1
        1:  173:    PASS();
call    0 returned 1
        1:  174:}
        -:  175:
        -:  176:/* ========== Tarjan State Tests ========== */
        -:  177:
function test_tarjan_init called 1 returned 100% blocks executed 39%
        1:  178:void test_tarjan_init(void) {
        1:  179:    TarjanState* state = tarjan_init(100);
call    0 returned 1
       1*:  180:    ASSERT_NOT_NULL(state);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:  181:    ASSERT_NOT_NULL(state->index);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:  182:    ASSERT_NOT_NULL(state->lowlink);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:  183:    ASSERT_NOT_NULL(state->on_stack);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:  184:    ASSERT_NOT_NULL(state->stack);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:  185:    ASSERT_EQ(state->stack_top, 0);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:  186:    ASSERT_EQ(state->current_index, 1);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:  187:    ASSERT_EQ(state->capacity, 100);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:  188:    tarjan_free(state);
call    0 returned 1
        1:  189:    PASS();
call    0 returned 1
        -:  190:}
        -:  191:
function test_tarjan_init_large called 1 returned 100% blocks executed 55%
        1:  192:void test_tarjan_init_large(void) {
        1:  193:    TarjanState* state = tarjan_init(10000);
call    0 returned 1
       1*:  194:    ASSERT_NOT_NULL(state);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:  195:    ASSERT_EQ(state->capacity, 10000);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:  196:    tarjan_free(state);
call    0 returned 1
        1:  197:    PASS();
call    0 returned 1
        -:  198:}
        -:  199:
function test_tarjan_free_null called 1 returned 100% blocks executed 100%
        1:  200:void test_tarjan_free_null(void) {
        1:  201:    tarjan_free(NULL);  /* Should not crash */
call    0 returned 1
        1:  202:    PASS();
call    0 returned 1
        1:  203:}
        -:  204:
        -:  205:/* ========== SCC Detection Tests ========== */
        -:  206:
function test_detect_sccs_single_obj called 1 returned 100% blocks executed 100%
        1:  207:void test_detect_sccs_single_obj(void) {
        1:  208:    Obj* obj = mk_int(42);
call    0 returned 1
        1:  209:    detect_and_freeze_sccs(obj);  /* Should handle single node */
call    0 returned 1
        1:  210:    dec_ref(obj);
call    0 returned 1
        1:  211:    PASS();
call    0 returned 1
        1:  212:}
        -:  213:
function test_detect_sccs_null called 1 returned 100% blocks executed 100%
        1:  214:void test_detect_sccs_null(void) {
        1:  215:    detect_and_freeze_sccs(NULL);  /* Should not crash */
call    0 returned 1
        1:  216:    PASS();
call    0 returned 1
        1:  217:}
        -:  218:
function test_detect_sccs_pair called 1 returned 100% blocks executed 100%
        1:  219:void test_detect_sccs_pair(void) {
        1:  220:    Obj* a = mk_int(1);
call    0 returned 1
        1:  221:    Obj* b = mk_int(2);
call    0 returned 1
        1:  222:    Obj* p = mk_pair(a, b);
call    0 returned 1
        1:  223:    detect_and_freeze_sccs(p);
call    0 returned 1
        1:  224:    dec_ref(p);
call    0 returned 1
        1:  225:    PASS();
call    0 returned 1
        1:  226:}
        -:  227:
function test_detect_sccs_list called 1 returned 100% blocks executed 100%
        1:  228:void test_detect_sccs_list(void) {
        -:  229:    /* Build list (1 2 3) */
        1:  230:    Obj* list = mk_pair(mk_int(1),
call    0 returned 1
call    1 returned 1
call    2 returned 1
call    3 returned 1
call    4 returned 1
call    5 returned 1
        -:  231:                        mk_pair(mk_int(2),
        -:  232:                                mk_pair(mk_int(3), NULL)));
        1:  233:    detect_and_freeze_sccs(list);
call    0 returned 1
        1:  234:    dec_ref(list);
call    0 returned 1
        1:  235:    PASS();
call    0 returned 1
        1:  236:}
        -:  237:
        -:  238:/* ========== Cyclic Structure Tests ========== */
        -:  239:
function test_detect_sccs_simple_cycle called 1 returned 100% blocks executed 62%
        1:  240:void test_detect_sccs_simple_cycle(void) {
        -:  241:    /* Create a simple cycle: A -> B -> A */
        1:  242:    Obj* a = mk_pair(NULL, NULL);
call    0 returned 1
        1:  243:    Obj* b = mk_pair(NULL, NULL);
call    0 returned 1
        1:  244:    a->a = b;  /* a -> b */
        1:  245:    b->a = a;  /* b -> a (creates cycle) */
        -:  246:
        1:  247:    detect_and_freeze_sccs(a);
call    0 returned 1
        -:  248:
        -:  249:    /* Both should be in same SCC */
       1*:  250:    ASSERT(a->scc_id >= 0);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:  251:    ASSERT_EQ(a->scc_id, b->scc_id);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        -:  252:
        -:  253:    /* Clean up */
        1:  254:    release_with_scc(a);
call    0 returned 1
        1:  255:    PASS();
call    0 returned 1
        -:  256:}
        -:  257:
function test_detect_sccs_self_loop called 1 returned 100% blocks executed 89%
        1:  258:void test_detect_sccs_self_loop(void) {
        -:  259:    /* Create self-referencing pair */
        1:  260:    Obj* a = mk_pair(NULL, NULL);
call    0 returned 1
        1:  261:    a->a = a;  /* Self-loop */
        -:  262:
        1:  263:    detect_and_freeze_sccs(a);
call    0 returned 1
        1:  264:    if (a->scc_id >= 0 && find_scc(a->scc_id)) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
branch  3 taken 0 (fallthrough)
branch  4 taken 1
    #####:  265:        release_with_scc(a);
call    0 never executed
        -:  266:    } else {
        -:  267:        /* Break cycle and free normally when SCC not detected */
        1:  268:        a->a = NULL;
        1:  269:        dec_ref(a);
call    0 returned 1
        -:  270:    }
        1:  271:    PASS();
call    0 returned 1
        1:  272:}
        -:  273:
        -:  274:/* ========== on_scc_found Callback Tests ========== */
        -:  275:
        -:  276:static int scc_found_count = 0;
        -:  277:static int last_scc_size = 0;
        -:  278:
function test_on_scc_found_callback called 1 returned 100% blocks executed 80%
        1:  279:void test_on_scc_found_callback(void) {
        1:  280:    Obj* members[] = {mk_int(1), mk_int(2), mk_int(3)};
call    0 returned 1
call    1 returned 1
call    2 returned 1
        1:  281:    int old_count = SCC_REGISTRY.next_id;
        1:  282:    on_scc_found(members, 3);
call    0 returned 1
       1*:  283:    ASSERT_EQ(SCC_REGISTRY.next_id, old_count + 1);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:  284:    SCC* scc = find_scc(old_count);
call    0 returned 1
        1:  285:    if (scc) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  286:        freeze_scc(scc);
call    0 returned 1
        1:  287:        release_scc(scc);
call    0 returned 1
        -:  288:    }
        1:  289:    PASS();
call    0 returned 1
        -:  290:}
        -:  291:
        -:  292:/* ========== SCC Capacity Tests ========== */
        -:  293:
function test_scc_member_capacity_growth called 1 returned 100% blocks executed 71%
        1:  294:void test_scc_member_capacity_growth(void) {
        1:  295:    SCC* scc = create_scc();
call    0 returned 1
        1:  296:    int initial_cap = scc->member_capacity;
        -:  297:    /* Add more members than initial capacity */
       49:  298:    for (int i = 0; i < initial_cap * 3; i++) {
branch  0 taken 48
branch  1 taken 1 (fallthrough)
       48:  299:        Obj* obj = mk_int(i);
call    0 returned 48
       48:  300:        scc_add_member(scc, obj);
call    0 returned 48
        -:  301:        /* Note: not dec_ref'ing because SCC owns them now */
        -:  302:    }
       1*:  303:    ASSERT(scc->member_capacity > initial_cap);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*:  304:    ASSERT_EQ(scc->member_count, initial_cap * 3);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:  305:    freeze_scc(scc);
call    0 returned 1
        1:  306:    release_scc(scc);
call    0 returned 1
        1:  307:    PASS();
call    0 returned 1
        -:  308:}
        -:  309:
        -:  310:/* ========== SCC Integration Tests ========== */
        -:  311:
function test_scc_full_lifecycle called 1 returned 100% blocks executed 68%
        1:  312:void test_scc_full_lifecycle(void) {
        -:  313:    /* Create SCC */
        1:  314:    SCC* scc = create_scc();
call    0 returned 1
        1:  315:    int scc_id = scc->id;
        -:  316:
        -:  317:    /* Add members */
        6:  318:    for (int i = 0; i < 5; i++) {
branch  0 taken 5
branch  1 taken 1 (fallthrough)
        5:  319:        Obj* obj = mk_int(i);
call    0 returned 5
        5:  320:        scc_add_member(scc, obj);
call    0 returned 5
        -:  321:    }
        -:  322:
        -:  323:    /* Freeze */
        1:  324:    freeze_scc(scc);
call    0 returned 1
       1*:  325:    ASSERT_EQ(scc->frozen, 1);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        -:  326:
        -:  327:    /* Find it */
        1:  328:    SCC* found = find_scc(scc_id);
call    0 returned 1
       1*:  329:    ASSERT_EQ(found, scc);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        -:  330:
        -:  331:    /* Release */
        1:  332:    release_scc(scc);
call    0 returned 1
        1:  333:    PASS();
call    0 returned 1
        -:  334:}
        -:  335:
        -:  336:/* ========== Stress Tests ========== */
        -:  337:
function test_scc_stress_many_members called 1 returned 100% blocks executed 79%
        1:  338:void test_scc_stress_many_members(void) {
        1:  339:    SCC* scc = create_scc();
call    0 returned 1
     1001:  340:    for (int i = 0; i < 1000; i++) {
branch  0 taken 1000
branch  1 taken 1 (fallthrough)
     1000:  341:        Obj* obj = mk_int(i);
call    0 returned 1000
     1000:  342:        scc_add_member(scc, obj);
call    0 returned 1000
        -:  343:    }
       1*:  344:    ASSERT_EQ(scc->member_count, 1000);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1:  345:    freeze_scc(scc);
call    0 returned 1
        1:  346:    release_scc(scc);
call    0 returned 1
        1:  347:    PASS();
call    0 returned 1
        -:  348:}
        -:  349:
function test_scc_stress_many_sccs called 1 returned 100% blocks executed 100%
        1:  350:void test_scc_stress_many_sccs(void) {
        -:  351:    SCC* sccs[100];
      101:  352:    for (int i = 0; i < 100; i++) {
branch  0 taken 100
branch  1 taken 1 (fallthrough)
      100:  353:        sccs[i] = create_scc();
call    0 returned 100
     1100:  354:        for (int j = 0; j < 10; j++) {
branch  0 taken 1000
branch  1 taken 100 (fallthrough)
     1000:  355:            Obj* obj = mk_int(i * 10 + j);
call    0 returned 1000
     1000:  356:            scc_add_member(sccs[i], obj);
call    0 returned 1000
        -:  357:        }
      100:  358:        freeze_scc(sccs[i]);
call    0 returned 100
        -:  359:    }
        -:  360:    /* Release all */
      101:  361:    for (int i = 0; i < 100; i++) {
branch  0 taken 100
branch  1 taken 1 (fallthrough)
      100:  362:        release_scc(sccs[i]);
call    0 returned 100
        -:  363:    }
        1:  364:    PASS();
call    0 returned 1
        1:  365:}
        -:  366:
function test_scc_stress_detect_many_trees called 1 returned 100% blocks executed 100%
        1:  367:void test_scc_stress_detect_many_trees(void) {
      101:  368:    for (int i = 0; i < 100; i++) {
branch  0 taken 100
branch  1 taken 1 (fallthrough)
      100:  369:        Obj* tree = mk_pair(
call    0 returned 100
call    1 returned 100
call    2 returned 100
call    3 returned 100
call    4 returned 100
call    5 returned 100
call    6 returned 100
        -:  370:            mk_pair(mk_int(1), mk_int(2)),
        -:  371:            mk_pair(mk_int(3), mk_int(4))
        -:  372:        );
      100:  373:        detect_and_freeze_sccs(tree);
call    0 returned 100
      100:  374:        dec_ref(tree);
call    0 returned 100
        -:  375:    }
        1:  376:    PASS();
call    0 returned 1
        1:  377:}
        -:  378:
        -:  379:/* ========== Run All SCC Tests ========== */
        -:  380:
function run_scc_tests called 1 returned 100% blocks executed 63%
        1:  381:void run_scc_tests(void) {
        1:  382:    TEST_SUITE("SCC Detection");
call    0 returned 1
        -:  383:
        1:  384:    TEST_SECTION("SCC Registry");
call    0 returned 1
       1*:  385:    RUN_TEST(test_scc_registry_init);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  386:    RUN_TEST(test_create_scc);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  387:    RUN_TEST(test_create_multiple_sccs);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  388:
        1:  389:    TEST_SECTION("Member Management");
call    0 returned 1
       1*:  390:    RUN_TEST(test_scc_add_member);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  391:    RUN_TEST(test_scc_add_multiple_members);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  392:    RUN_TEST(test_scc_add_member_null_scc);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  393:    RUN_TEST(test_scc_add_member_null_obj);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  394:
        1:  395:    TEST_SECTION("Freeze");
call    0 returned 1
       1*:  396:    RUN_TEST(test_freeze_scc);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  397:    RUN_TEST(test_freeze_scc_null);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  398:
        1:  399:    TEST_SECTION("Lookup");
call    0 returned 1
       1*:  400:    RUN_TEST(test_find_scc);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  401:    RUN_TEST(test_find_scc_not_found);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  402:
        1:  403:    TEST_SECTION("Reference Counting");
call    0 returned 1
       1*:  404:    RUN_TEST(test_release_scc_single_ref);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  405:    RUN_TEST(test_release_scc_null);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  406:    RUN_TEST(test_release_scc_not_frozen);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  407:
        1:  408:    TEST_SECTION("release_with_scc");
call    0 returned 1
       1*:  409:    RUN_TEST(test_release_with_scc_member);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  410:    RUN_TEST(test_release_with_scc_non_member);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  411:    RUN_TEST(test_release_with_scc_null);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  412:
        1:  413:    TEST_SECTION("Tarjan State");
call    0 returned 1
       1*:  414:    RUN_TEST(test_tarjan_init);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  415:    RUN_TEST(test_tarjan_init_large);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  416:    RUN_TEST(test_tarjan_free_null);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  417:
        1:  418:    TEST_SECTION("SCC Detection");
call    0 returned 1
       1*:  419:    RUN_TEST(test_detect_sccs_single_obj);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  420:    RUN_TEST(test_detect_sccs_null);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  421:    RUN_TEST(test_detect_sccs_pair);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  422:    RUN_TEST(test_detect_sccs_list);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  423:
        1:  424:    TEST_SECTION("Cyclic Structures");
call    0 returned 1
       1*:  425:    RUN_TEST(test_detect_sccs_simple_cycle);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  426:    RUN_TEST(test_detect_sccs_self_loop);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  427:
        1:  428:    TEST_SECTION("Callback");
call    0 returned 1
       1*:  429:    RUN_TEST(test_on_scc_found_callback);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  430:
        1:  431:    TEST_SECTION("Capacity Growth");
call    0 returned 1
       1*:  432:    RUN_TEST(test_scc_member_capacity_growth);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  433:
        1:  434:    TEST_SECTION("Integration");
call    0 returned 1
       1*:  435:    RUN_TEST(test_scc_full_lifecycle);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        -:  436:
        1:  437:    TEST_SECTION("Stress Tests");
call    0 returned 1
       1*:  438:    RUN_TEST(test_scc_stress_many_members);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  439:    RUN_TEST(test_scc_stress_many_sccs);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
       1*:  440:    RUN_TEST(test_scc_stress_detect_many_trees);
call    0 returned 1
call    1 returned 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 never executed (fallthrough)
branch  5 never executed
call    6 never executed
        1:  441:}
