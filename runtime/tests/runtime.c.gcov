        -:    0:Source:../src/runtime.c
        -:    0:Graph:./run_tests_cov-test_main.gcno
        -:    0:Data:./run_tests_cov-test_main.gcda
        -:    0:Runs:1
        -:    1:/* Purple + ASAP C Compiler Output */
        -:    2:/* Primary Strategy: ASAP + ISMM 2024 (Deeply Immutable Cycles) */
        -:    3:/* Generated ANSI C99 + POSIX Code */
        -:    4:
        -:    5:/* Enable POSIX.1-2001 for pthread_rwlock_t and related functions */
        -:    6:#define _POSIX_C_SOURCE 200112L
        -:    7:
        -:    8:#include <stdlib.h>
        -:    9:#include <stdio.h>
        -:   10:#include <limits.h>
        -:   11:#include <stdint.h>
        -:   12:#include <string.h>
        -:   13:#include <pthread.h>
        -:   14:#include <stdbool.h>
        -:   15:
        -:   16:/* ========== Tagged Pointers (Multi-Type Immediates) ========== */
        -:   17:/*
        -:   18: * 3-bit tag scheme for immediate values (no heap allocation):
        -:   19: *
        -:   20: * Low 3 bits | Type        | Payload
        -:   21: * -----------|-------------|------------------
        -:   22: *    000     | Heap ptr    | 64-bit pointer (aligned)
        -:   23: *    001     | Integer     | 61-bit signed int
        -:   24: *    010     | Character   | 21-bit Unicode codepoint
        -:   25: *    011     | Boolean     | 1-bit (0=false, 1=true)
        -:   26: */
        -:   27:
        -:   28:/* 3-bit tag constants */
        -:   29:#define IMM_TAG_MASK     0x7ULL
        -:   30:#define IMM_TAG_PTR      0x0ULL
        -:   31:#define IMM_TAG_INT      0x1ULL
        -:   32:#define IMM_TAG_CHAR     0x2ULL
        -:   33:#define IMM_TAG_BOOL     0x3ULL
        -:   34:
        -:   35:/* Extract tag from value */
        -:   36:#define GET_IMM_TAG(p)   (((uintptr_t)(p)) & IMM_TAG_MASK)
        -:   37:
        -:   38:/* Check immediate types */
        -:   39:#define IS_IMMEDIATE(p)      (GET_IMM_TAG(p) != IMM_TAG_PTR)
        -:   40:#define IS_IMMEDIATE_INT(p)  (GET_IMM_TAG(p) == IMM_TAG_INT)
        -:   41:#define IS_IMMEDIATE_CHAR(p) (GET_IMM_TAG(p) == IMM_TAG_CHAR)
        -:   42:#define IS_IMMEDIATE_BOOL(p) (GET_IMM_TAG(p) == IMM_TAG_BOOL)
        -:   43:#define IS_BOXED(p)          (GET_IMM_TAG(p) == IMM_TAG_PTR && (p) != NULL)
        -:   44:
        -:   45:/* Immediate Integers */
        -:   46:#define MAKE_INT_IMM(n)      ((Obj*)(((uintptr_t)(n) << 3) | IMM_TAG_INT))
        -:   47:#define INT_IMM_VALUE(p)     ((long)((intptr_t)(p) >> 3))
        -:   48:
        -:   49:/* Backward compatibility */
        -:   50:#define MAKE_IMMEDIATE(n)    MAKE_INT_IMM(n)
        -:   51:#define IMMEDIATE_VALUE(p)   INT_IMM_VALUE(p)
        -:   52:
        -:   53:/* Immediate Booleans */
        -:   54:#define PURPLE_FALSE         ((Obj*)(((uintptr_t)0 << 3) | IMM_TAG_BOOL))
        -:   55:#define PURPLE_TRUE          ((Obj*)(((uintptr_t)1 << 3) | IMM_TAG_BOOL))
        -:   56:
        -:   57:/* Immediate Characters */
        -:   58:#define MAKE_CHAR_IMM(c)     ((Obj*)(((uintptr_t)(c) << 3) | IMM_TAG_CHAR))
        -:   59:#define CHAR_IMM_VALUE(p)    ((long)(((uintptr_t)(p)) >> 3))
        -:   60:
        -:   61:/* ========== IPGE: In-Place Generational Evolution ========== */
        -:   62:/*
        -:   63: * Two modes available (controlled by IPGE_ROBUST_MODE):
        -:   64: * - COMPACT (default): 16-bit generation, 64-bit packed refs
        -:   65: * - ROBUST: 64-bit generation, 128-bit refs (more collision resistant)
        -:   66: */
        -:   67:#ifndef IPGE_ROBUST_MODE
        -:   68:#define IPGE_ROBUST_MODE 0
        -:   69:#endif
        -:   70:
        -:   71:#if IPGE_ROBUST_MODE
        -:   72:/* ROBUST: 64-bit generation (18 quintillion cycles) */
        -:   73:#define IPGE_MULTIPLIER  0x5851f42D4C957F2DULL
        -:   74:#define IPGE_INCREMENT   0x1442695040888963ULL
        -:   75:typedef uint64_t Generation;
        -:   76:static inline Generation ipge_evolve(Generation gen) {
        -:   77:    return (gen * IPGE_MULTIPLIER) + IPGE_INCREMENT;
        -:   78:}
        -:   79:#else
        -:   80:/* COMPACT: 16-bit generation (65K cycles per slot) */
        -:   81:#define IPGE16_MULTIPLIER  0xAC4BULL
        -:   82:#define IPGE16_INCREMENT   0x9E37ULL
        -:   83:typedef uint16_t Generation;
function ipge_evolve called 20221 returned 100% blocks executed 100%
    20221:   84:static inline Generation ipge_evolve(Generation gen) {
    20221:   85:    return (Generation)((gen * IPGE16_MULTIPLIER) + IPGE16_INCREMENT);
        -:   86:}
        -:   87:#endif
        -:   88:
        -:   89:/* 64-bit evolution for seed (always use full period for seeding) */
        -:   90:#define IPGE64_MULTIPLIER  0x5851f42D4C957F2DULL
        -:   91:#define IPGE64_INCREMENT   0x1442695040888963ULL
function ipge_evolve64 called 120942 returned 100% blocks executed 100%
   120942:   92:static inline uint64_t ipge_evolve64(uint64_t gen) {
   120942:   93:    return (gen * IPGE64_MULTIPLIER) + IPGE64_INCREMENT;
        -:   94:}
        -:   95:
        -:   96:/* Forward declarations */
        -:   97:typedef struct Obj Obj;
        -:   98:typedef struct GenObj GenObj;
        -:   99:typedef struct Closure Closure;
        -:  100:
        -:  101:/* BorrowRef: Legacy heap-allocated reference for compatibility.
        -:  102: * New code should use BorrowedRef (packed 64-bit) from purple.h */
        -:  103:typedef struct BorrowRef {
        -:  104:    struct GenObj* target;       /* Legacy GenObj system */
        -:  105:    Generation remembered_gen;   /* Snapshot of generation at borrow time */
        -:  106:    const char* source_desc;     /* Debug description */
        -:  107:    struct Obj* ipge_target;     /* IPGE: Direct Obj* for generation check */
        -:  108:} BorrowRef;
        -:  109:
        -:  110:void invalidate_weak_refs_for(void* target);
        -:  111:BorrowRef* borrow_create(Obj* obj, const char* source_desc);
        -:  112:void borrow_invalidate_obj(Obj* obj);
        -:  113:Obj* call_closure(Obj* clos, Obj** args, int arg_count);
        -:  114:void closure_release(Closure* c);
        -:  115:void release_user_obj(Obj* x);
        -:  116:void free_channel_obj(Obj* ch_obj);
        -:  117:void free_atom_obj(Obj* atom_obj);
        -:  118:void free_thread_obj(Obj* thread_obj);
        -:  119:void scan_user_obj(Obj* obj);
        -:  120:void clear_marks_user_obj(Obj* obj);
        -:  121:
        -:  122:/* Reference counting forward declarations */
        -:  123:void inc_ref(Obj* x);
        -:  124:void dec_ref(Obj* x);
        -:  125:void free_obj(Obj* x);
        -:  126:
        -:  127:/* Primitive operations forward declarations */
        -:  128:Obj* prim_add(Obj* a, Obj* b);
        -:  129:Obj* prim_sub(Obj* a, Obj* b);
        -:  130:Obj* prim_mul(Obj* a, Obj* b);
        -:  131:Obj* prim_div(Obj* a, Obj* b);
        -:  132:Obj* prim_mod(Obj* a, Obj* b);
        -:  133:Obj* prim_lt(Obj* a, Obj* b);
        -:  134:Obj* prim_gt(Obj* a, Obj* b);
        -:  135:Obj* prim_le(Obj* a, Obj* b);
        -:  136:Obj* prim_ge(Obj* a, Obj* b);
        -:  137:Obj* prim_eq(Obj* a, Obj* b);
        -:  138:Obj* prim_not(Obj* a);
        -:  139:Obj* prim_abs(Obj* a);
        -:  140:Obj* prim_null(Obj* x);
        -:  141:Obj* prim_pair(Obj* x);
        -:  142:Obj* prim_int(Obj* x);
        -:  143:Obj* prim_float(Obj* x);
        -:  144:Obj* prim_char(Obj* x);
        -:  145:Obj* prim_sym(Obj* x);
        -:  146:Obj* obj_car(Obj* p);
        -:  147:Obj* obj_cdr(Obj* p);
        -:  148:
        -:  149:/* I/O primitive forward declarations */
        -:  150:Obj* prim_display(Obj* x);
        -:  151:Obj* prim_print(Obj* x);
        -:  152:Obj* prim_newline(void);
        -:  153:
        -:  154:/* List operation forward declarations */
        -:  155:Obj* list_append(Obj* a, Obj* b);
        -:  156:Obj* list_filter(Obj* fn, Obj* xs);
        -:  157:Obj* list_reverse(Obj* xs);
        -:  158:
        -:  159:/* Type introspection forward declarations */
        -:  160:Obj* ctr_tag(Obj* x);
        -:  161:Obj* ctr_arg(Obj* x, Obj* idx);
        -:  162:
        -:  163:/* Character primitive forward declarations */
        -:  164:Obj* char_to_int(Obj* c);
        -:  165:Obj* int_to_char(Obj* n);
        -:  166:
        -:  167:/* Float primitive forward declarations */
        -:  168:Obj* int_to_float(Obj* n);
        -:  169:Obj* float_to_int(Obj* f);
        -:  170:Obj* prim_floor(Obj* f);
        -:  171:Obj* prim_ceil(Obj* f);
        -:  172:
        -:  173:/* Higher-order function forward declarations */
        -:  174:Obj* prim_apply(Obj* fn, Obj* args);
        -:  175:Obj* prim_compose(Obj* f, Obj* g);
        -:  176:
        -:  177:/* Core tags for runtime values */
        -:  178:typedef enum {
        -:  179:    TAG_INT = 1,
        -:  180:    TAG_FLOAT,
        -:  181:    TAG_CHAR,
        -:  182:    TAG_PAIR,
        -:  183:    TAG_SYM,
        -:  184:    TAG_BOX,
        -:  185:    TAG_CLOSURE,
        -:  186:    TAG_CHANNEL,
        -:  187:    TAG_ERROR,
        -:  188:    TAG_ATOM,
        -:  189:    TAG_THREAD
        -:  190:} ObjTag;
        -:  191:
        -:  192:#define TAG_USER_BASE 1000
        -:  193:
        -:  194:/* Core object type */
        -:  195:typedef struct Obj {
        -:  196:    Generation generation;  /* IPGE generation ID for memory safety */
        -:  197:    int mark;               /* Reference count or mark bit */
        -:  198:    int tag;                /* ObjTag */
        -:  199:    int is_pair;            /* 1 if pair, 0 if not */
        -:  200:    int scc_id;             /* SCC identifier for cycle detection (-1 = none) */
        -:  201:    unsigned int scan_tag;  /* Scanner mark (separate from RC) */
        -:  202:    union {
        -:  203:        long i;
        -:  204:        double f;
        -:  205:        struct { struct Obj *a, *b; };
        -:  206:        void* ptr;
        -:  207:    };
        -:  208:} Obj;
        -:  209:/* Size: 32 bytes (compact) or 40 bytes (robust) */
        -:  210:
        -:  211:/* ========== Tagged Pointer Helper Functions ========== */
        -:  212:
        -:  213:/* Unboxed integer constructor - returns immediate, no heap! */
function mk_int_unboxed called 13104 returned 100% blocks executed 100%
    13104:  214:static inline Obj* mk_int_unboxed(long i) {
    13104:  215:    return MAKE_INT_IMM(i);
        -:  216:}
        -:  217:
        -:  218:/* Unboxed boolean constructor */
function mk_bool called 4 returned 100% blocks executed 100%
        4:  219:static inline Obj* mk_bool(int b) {
        4:  220:    return b ? PURPLE_TRUE : PURPLE_FALSE;
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        -:  221:}
        -:  222:
        -:  223:/* Unboxed character constructor */
function mk_char_unboxed called 145 returned 100% blocks executed 100%
      145:  224:static inline Obj* mk_char_unboxed(long c) {
      145:  225:    return MAKE_CHAR_IMM(c);
        -:  226:}
        -:  227:
        -:  228:/* Safe integer extraction - works for both boxed and immediate */
function obj_to_int called 3527 returned 100% blocks executed 100%
     3527:  229:static inline long obj_to_int(Obj* p) {
     3527:  230:    if (IS_IMMEDIATE_INT(p)) return INT_IMM_VALUE(p);
branch  0 taken 1034 (fallthrough)
branch  1 taken 2493
     2493:  231:    if (IS_IMMEDIATE_BOOL(p)) return p == PURPLE_TRUE ? 1 : 0;
branch  0 taken 2 (fallthrough)
branch  1 taken 2491
     2491:  232:    if (IS_IMMEDIATE_CHAR(p)) return CHAR_IMM_VALUE(p);
branch  0 taken 1 (fallthrough)
branch  1 taken 2490
     2490:  233:    return p ? p->i : 0;
branch  0 taken 2489 (fallthrough)
branch  1 taken 1
        -:  234:}
        -:  235:
        -:  236:/* Safe boolean extraction */
function obj_to_bool called 13 returned 100% blocks executed 100%
       13:  237:static inline int obj_to_bool(Obj* p) {
       13:  238:    if (IS_IMMEDIATE_BOOL(p)) return p == PURPLE_TRUE;
branch  0 taken 4 (fallthrough)
branch  1 taken 9
        9:  239:    if (IS_IMMEDIATE_INT(p)) return INT_IMM_VALUE(p) != 0;
branch  0 taken 7 (fallthrough)
branch  1 taken 2
        2:  240:    if (p == NULL) return 0;
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  241:    return 1;  /* Non-null is truthy */
        -:  242:}
        -:  243:
        -:  244:/* Safe character extraction */
function obj_to_char_val called 6 returned 100% blocks executed 43%
        6:  245:static inline long obj_to_char_val(Obj* p) {
        6:  246:    if (IS_IMMEDIATE_CHAR(p)) return CHAR_IMM_VALUE(p);
branch  0 taken 6 (fallthrough)
branch  1 taken 0
    #####:  247:    if (p && p->tag == TAG_CHAR) return p->i;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####:  248:    return 0;
        -:  249:}
        -:  250:
        -:  251:/* Safe tag extraction - works for all immediate types */
function obj_tag called 70 returned 100% blocks executed 100%
       70:  252:static inline int obj_tag(Obj* p) {
       70:  253:    if (p == NULL) return 0;
branch  0 taken 1 (fallthrough)
branch  1 taken 69
       69:  254:    if (IS_IMMEDIATE_INT(p)) return TAG_INT;
branch  0 taken 3 (fallthrough)
branch  1 taken 66
       66:  255:    if (IS_IMMEDIATE_CHAR(p)) return TAG_CHAR;
branch  0 taken 6 (fallthrough)
branch  1 taken 60
       60:  256:    if (IS_IMMEDIATE_BOOL(p)) return TAG_INT;  /* Booleans are int-like */
branch  0 taken 1 (fallthrough)
branch  1 taken 59
       59:  257:    return p->tag;
        -:  258:}
        -:  259:
        -:  260:/* Check if value is an integer (boxed or immediate) */
function is_int called 7 returned 100% blocks executed 100%
        7:  261:static inline int is_int(Obj* p) {
        7:  262:    if (IS_IMMEDIATE_INT(p) || IS_IMMEDIATE_BOOL(p)) return 1;
branch  0 taken 6 (fallthrough)
branch  1 taken 1
branch  2 taken 2 (fallthrough)
branch  3 taken 4
        4:  263:    if (IS_IMMEDIATE(p)) return 0;  /* Other immediate types (char) are not int */
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        3:  264:    return p && p->tag == TAG_INT;
branch  0 taken 2 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        -:  265:}
        -:  266:
        -:  267:/* Check if value is a character (boxed or immediate) */
function is_char called 3 returned 100% blocks executed 80%
        3:  268:static inline int is_char(Obj* p) {
        3:  269:    if (IS_IMMEDIATE_CHAR(p)) return 1;
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        2:  270:    if (IS_IMMEDIATE(p)) return 0;  /* Other immediate types are not char */
branch  0 taken 1 (fallthrough)
branch  1 taken 1
       1*:  271:    return p && p->tag == TAG_CHAR;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed (fallthrough)
branch  3 never executed
        -:  272:}
        -:  273:
        -:  274:/* Dynamic Free List */
        -:  275:typedef struct FreeNode {
        -:  276:    Obj* obj;
        -:  277:    struct FreeNode* next;
        -:  278:} FreeNode;
        -:  279:
        -:  280:FreeNode* FREE_HEAD = NULL;
        -:  281:int FREE_COUNT = 0;
        -:  282:
        -:  283:/* Stack Allocation Pool */
        -:  284:#define STACK_POOL_SIZE 256
        -:  285:Obj STACK_POOL[STACK_POOL_SIZE];
        -:  286:int STACK_PTR = 0;
        -:  287:
function is_stack_obj called 18827 returned 100% blocks executed 100%
    18827:  288:int is_stack_obj(Obj* x) {
    18827:  289:    uintptr_t px = (uintptr_t)x;
    18827:  290:    uintptr_t start = (uintptr_t)&STACK_POOL[0];
    18827:  291:    uintptr_t end = (uintptr_t)&STACK_POOL[STACK_POOL_SIZE];
    18827:  292:    return px >= start && px < end;
branch  0 taken 18826 (fallthrough)
branch  1 taken 1
branch  2 taken 3 (fallthrough)
branch  3 taken 18823
        -:  293:}
        -:  294:
function is_nil called 2 returned 100% blocks executed 100%
        2:  295:int is_nil(Obj* x) {
        2:  296:    return x == NULL;
        -:  297:}
        -:  298:
        -:  299:/* Internal Weak Reference Support */
        -:  300:/* NOTE: This is internal to the runtime. Users should not use WeakRef directly.
        -:  301:   The compiler automatically detects back-edges and generates appropriate code. */
        -:  302:
        -:  303:typedef struct _InternalWeakRef {
        -:  304:    void* target;
        -:  305:    int alive;
        -:  306:} _InternalWeakRef;
        -:  307:
        -:  308:typedef struct _InternalWeakRefNode {
        -:  309:    _InternalWeakRef* ref;
        -:  310:    struct _InternalWeakRefNode* next;
        -:  311:} _InternalWeakRefNode;
        -:  312:
        -:  313:_InternalWeakRefNode* _WEAK_REF_HEAD = NULL;
        -:  314:
function _mk_weak_ref called 281 returned 100% blocks executed 67%
      281:  315:static _InternalWeakRef* _mk_weak_ref(void* target) {
      281:  316:    _InternalWeakRef* w = malloc(sizeof(_InternalWeakRef));
     281*:  317:    if (!w) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 281
      281:  318:    w->target = target;
      281:  319:    w->alive = 1;
      281:  320:    _InternalWeakRefNode* node = malloc(sizeof(_InternalWeakRefNode));
     281*:  321:    if (!node) { free(w); return NULL; }
branch  0 taken 0 (fallthrough)
branch  1 taken 281
      281:  322:    node->ref = w;
      281:  323:    node->next = _WEAK_REF_HEAD;
      281:  324:    _WEAK_REF_HEAD = node;
      281:  325:    return w;
        -:  326:}
        -:  327:
function _deref_weak called 8 returned 100% blocks executed 100%
        8:  328:static void* _deref_weak(_InternalWeakRef* w) {
        8:  329:    if (w && w->alive) return w->target;
branch  0 taken 7 (fallthrough)
branch  1 taken 1
branch  2 taken 3 (fallthrough)
branch  3 taken 4
        5:  330:    return NULL;
        -:  331:}
        -:  332:
function _invalidate_weak called 793 returned 100% blocks executed 100%
      793:  333:void _invalidate_weak(_InternalWeakRef* w) {
      793:  334:    if (w) w->alive = 0;
branch  0 taken 792 (fallthrough)
branch  1 taken 1
      793:  335:}
        -:  336:
function invalidate_weak_refs_for called 12222 returned 100% blocks executed 100%
    12222:  337:void invalidate_weak_refs_for(void* target) {
    12222:  338:    _InternalWeakRefNode* n = _WEAK_REF_HEAD;
   618593:  339:    while (n) {
branch  0 taken 606371
branch  1 taken 12222 (fallthrough)
   606371:  340:        _InternalWeakRef* obj = n->ref;
   606371:  341:        if (obj->target == target) {
branch  0 taken 785 (fallthrough)
branch  1 taken 605586
      785:  342:            _invalidate_weak(obj);
call    0 returned 785
        -:  343:        }
   606371:  344:        n = n->next;
        -:  345:    }
    12222:  346:}
        -:  347:
        -:  348:/* IPGE generation seed - evolves with each allocation
        -:  349: * Uses 64-bit LCG for full randomness, truncated to Generation type.
        -:  350: * This gives each allocation a pseudo-random starting generation. */
        -:  351:static uint64_t _ipge_seed = 0x123456789ABCDEF0ULL;
        -:  352:
function _next_generation called 120842 returned 100% blocks executed 100%
   120842:  353:static inline Generation _next_generation(void) {
   120842:  354:    _ipge_seed = ipge_evolve64(_ipge_seed);
call    0 returned 120842
   120842:  355:    return (Generation)_ipge_seed;  /* Truncate to 16-bit (compact) or keep 64-bit (robust) */
        -:  356:}
        -:  357:
        -:  358:/* Object Constructors */
function mk_int called 9806 returned 100% blocks executed 80%
     9806:  359:Obj* mk_int(long i) {
     9806:  360:    Obj* x = malloc(sizeof(Obj));
    9806*:  361:    if (!x) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 9806
     9806:  362:    x->generation = _next_generation();
call    0 returned 9806
     9806:  363:    x->mark = 1;
     9806:  364:    x->tag = TAG_INT;
     9806:  365:    x->is_pair = 0;
     9806:  366:    x->i = i;
     9806:  367:    return x;
        -:  368:}
        -:  369:
function mk_float called 29 returned 100% blocks executed 80%
       29:  370:Obj* mk_float(double f) {
       29:  371:    Obj* x = malloc(sizeof(Obj));
      29*:  372:    if (!x) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 29
       29:  373:    x->generation = _next_generation();
call    0 returned 29
       29:  374:    x->mark = 1;
       29:  375:    x->tag = TAG_FLOAT;
       29:  376:    x->is_pair = 0;
       29:  377:    x->f = f;
       29:  378:    return x;
        -:  379:}
        -:  380:
function get_float called 0 returned 0% blocks executed 0%
    #####:  381:double get_float(Obj* x) {
    #####:  382:    if (!x) return 0.0;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  383:    return x->f;
        -:  384:}
        -:  385:
function mk_char called 7 returned 100% blocks executed 56%
        7:  386:Obj* mk_char(long c) {
        -:  387:    /* Use unboxed for Unicode codepoints */
        7:  388:    if (c >= 0 && c <= 0x10FFFF) {
branch  0 taken 7 (fallthrough)
branch  1 taken 0
branch  2 taken 7 (fallthrough)
branch  3 taken 0
        7:  389:        return mk_char_unboxed(c);
call    0 returned 7
        -:  390:    }
        -:  391:    /* Fallback to boxed for invalid codepoints */
    #####:  392:    Obj* x = malloc(sizeof(Obj));
    #####:  393:    if (!x) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  394:    x->generation = _next_generation();
call    0 never executed
    #####:  395:    x->mark = 1;
    #####:  396:    x->tag = TAG_CHAR;
    #####:  397:    x->is_pair = 0;
    #####:  398:    x->i = c;
    #####:  399:    return x;
        -:  400:}
        -:  401:
function mk_pair called 2330 returned 100% blocks executed 80%
     2330:  402:Obj* mk_pair(Obj* a, Obj* b) {
     2330:  403:    Obj* x = malloc(sizeof(Obj));
    2330*:  404:    if (!x) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 2330
     2330:  405:    x->generation = _next_generation();
call    0 returned 2330
     2330:  406:    x->mark = 1;
     2330:  407:    x->tag = TAG_PAIR;
     2330:  408:    x->is_pair = 1;
        -:  409:    /* Move semantics: ownership transfers to pair, no inc_ref needed */
     2330:  410:    x->a = a;
     2330:  411:    x->b = b;
     2330:  412:    return x;
        -:  413:}
        -:  414:
function mk_sym called 9 returned 100% blocks executed 80%
        9:  415:Obj* mk_sym(const char* s) {
        9:  416:    Obj* x = malloc(sizeof(Obj));
       9*:  417:    if (!x) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 9
        9:  418:    x->generation = _next_generation();
call    0 returned 9
        9:  419:    x->mark = 1;
        9:  420:    x->tag = TAG_SYM;
        9:  421:    x->is_pair = 0;
        9:  422:    if (s) {
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:  423:        size_t len = strlen(s);
        8:  424:        char* copy = malloc(len + 1);
        8:  425:        if (!copy) {
branch  0 taken 0 (fallthrough)
branch  1 taken 8
    #####:  426:            free(x);
    #####:  427:            return NULL;
        -:  428:        }
        8:  429:        memcpy(copy, s, len + 1);
        8:  430:        x->ptr = copy;
        -:  431:    } else {
        1:  432:        x->ptr = NULL;
        -:  433:    }
        9:  434:    return x;
        -:  435:}
        -:  436:
function mk_box called 7 returned 100% blocks executed 86%
        7:  437:Obj* mk_box(Obj* v) {
        7:  438:    Obj* x = malloc(sizeof(Obj));
       7*:  439:    if (!x) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 7
        7:  440:    x->generation = _next_generation();
call    0 returned 7
        7:  441:    x->mark = 1;
        7:  442:    x->tag = TAG_BOX;
        7:  443:    x->is_pair = 0;
        7:  444:    if (v) inc_ref(v);
branch  0 taken 5 (fallthrough)
branch  1 taken 2
call    2 returned 5
        7:  445:    x->ptr = v;
        7:  446:    return x;
        -:  447:}
        -:  448:
function box_get called 8 returned 100% blocks executed 100%
        8:  449:Obj* box_get(Obj* b) {
        8:  450:    if (!b || b->tag != TAG_BOX) return NULL;
branch  0 taken 7 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 6
        6:  451:    return (Obj*)b->ptr;
        -:  452:}
        -:  453:
function box_set called 3 returned 100% blocks executed 100%
        3:  454:void box_set(Obj* b, Obj* v) {
        3:  455:    if (!b || b->tag != TAG_BOX) return;
branch  0 taken 2 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
        2:  456:    if (v) inc_ref(v);
branch  0 taken 1 (fallthrough)
branch  1 taken 1
call    2 returned 1
        2:  457:    if (b->ptr) dec_ref((Obj*)b->ptr);
branch  0 taken 2 (fallthrough)
branch  1 taken 0
call    2 returned 2
        2:  458:    b->ptr = v;
        -:  459:}
        -:  460:
function mk_error called 4 returned 100% blocks executed 80%
        4:  461:Obj* mk_error(const char* msg) {
        4:  462:    Obj* x = malloc(sizeof(Obj));
       4*:  463:    if (!x) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        4:  464:    x->mark = 1;
        4:  465:    x->scc_id = -1;
        4:  466:    x->is_pair = 0;
        4:  467:    x->scan_tag = 0;
        4:  468:    x->tag = TAG_ERROR;
        4:  469:    x->generation = _next_generation();
call    0 returned 4
        4:  470:    if (msg) {
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:  471:        size_t len = strlen(msg);
        3:  472:        char* copy = malloc(len + 1);
        3:  473:        if (!copy) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:  474:            free(x);
    #####:  475:            return NULL;
        -:  476:        }
        3:  477:        memcpy(copy, msg, len + 1);
        3:  478:        x->ptr = copy;
        -:  479:    } else {
        1:  480:        x->ptr = NULL;
        -:  481:    }
        4:  482:    return x;
        -:  483:}
        -:  484:
function mk_int_stack called 5 returned 100% blocks executed 100%
        5:  485:Obj* mk_int_stack(long i) {
        5:  486:    if (STACK_PTR < STACK_POOL_SIZE) {
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        4:  487:        Obj* x = &STACK_POOL[STACK_PTR++];
        4:  488:        x->mark = 0;
        4:  489:        x->scc_id = -1;
        4:  490:        x->is_pair = 0;
        4:  491:        x->scan_tag = 0;
        4:  492:        x->tag = TAG_INT;
        4:  493:        x->generation = _next_generation();
call    0 returned 4
        4:  494:        x->i = i;
        4:  495:        return x;
        -:  496:    }
        1:  497:    return mk_int(i);
call    0 returned 1
        -:  498:}
        -:  499:
function mk_float_stack called 0 returned 0% blocks executed 0%
    #####:  500:Obj* mk_float_stack(double f) {
    #####:  501:    if (STACK_PTR < STACK_POOL_SIZE) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  502:        Obj* x = &STACK_POOL[STACK_PTR++];
    #####:  503:        x->mark = 0;
    #####:  504:        x->scc_id = -1;
    #####:  505:        x->is_pair = 0;
    #####:  506:        x->scan_tag = 0;
    #####:  507:        x->tag = TAG_FLOAT;
    #####:  508:        x->generation = _next_generation();
call    0 never executed
    #####:  509:        x->f = f;
    #####:  510:        return x;
        -:  511:    }
    #####:  512:    return mk_float(f);
call    0 never executed
        -:  513:}
        -:  514:
function mk_char_stack called 0 returned 0% blocks executed 0%
    #####:  515:Obj* mk_char_stack(long c) {
    #####:  516:    if (STACK_PTR < STACK_POOL_SIZE) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  517:        Obj* x = &STACK_POOL[STACK_PTR++];
    #####:  518:        x->mark = 0;
    #####:  519:        x->scc_id = -1;
    #####:  520:        x->is_pair = 0;
    #####:  521:        x->scan_tag = 0;
    #####:  522:        x->tag = TAG_CHAR;
    #####:  523:        x->generation = _next_generation();
call    0 never executed
    #####:  524:        x->i = c;
    #####:  525:        return x;
        -:  526:    }
    #####:  527:    return mk_char(c);
call    0 never executed
        -:  528:}
        -:  529:
        -:  530:/* Shape-based Deallocation (Ghiya-Hendren analysis) */
        -:  531:
function release_children called 9831 returned 100% blocks executed 90%
     9831:  532:void release_children(Obj* x) {
    9831*:  533:    if (!x) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 9831
    9831*:  534:    if (IS_IMMEDIATE(x)) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 9831
     9831:  535:    switch (x->tag) {
branch  0 taken 2221
branch  1 taken 8
branch  2 taken 1049
branch  3 taken 15
branch  4 taken 3
branch  5 taken 2
branch  6 taken 2
branch  7 taken 6531
     2221:  536:    case TAG_PAIR:
     2221:  537:        dec_ref(x->a);
call    0 returned 2221
     2221:  538:        dec_ref(x->b);
call    0 returned 2221
     2221:  539:        break;
        8:  540:    case TAG_BOX:
        8:  541:        if (x->ptr) dec_ref((Obj*)x->ptr);
branch  0 taken 4 (fallthrough)
branch  1 taken 4
call    2 returned 4
        8:  542:        break;
     1049:  543:    case TAG_CLOSURE:
     1049:  544:        if (x->ptr) closure_release((Closure*)x->ptr);
branch  0 taken 1048 (fallthrough)
branch  1 taken 1
call    2 returned 1048
     1049:  545:        break;
       15:  546:    case TAG_SYM:
        -:  547:    case TAG_ERROR:
       15:  548:        if (x->ptr) free(x->ptr);
branch  0 taken 11 (fallthrough)
branch  1 taken 4
       15:  549:        break;
        3:  550:    case TAG_CHANNEL:
        3:  551:        if (x->ptr) free_channel_obj(x);
branch  0 taken 2 (fallthrough)
branch  1 taken 1
call    2 returned 2
        3:  552:        break;
        2:  553:    case TAG_ATOM:
        2:  554:        if (x->ptr) free_atom_obj(x);
branch  0 taken 1 (fallthrough)
branch  1 taken 1
call    2 returned 1
        2:  555:        break;
        2:  556:    case TAG_THREAD:
        2:  557:        if (x->ptr) free_thread_obj(x);
branch  0 taken 1 (fallthrough)
branch  1 taken 1
call    2 returned 1
        2:  558:        break;
     6531:  559:    default:
     6531:  560:        if (x->tag >= TAG_USER_BASE) {
branch  0 taken 0 (fallthrough)
branch  1 taken 6531
    #####:  561:            release_user_obj(x);
call    0 never executed
        -:  562:        }
     6531:  563:        break;
        -:  564:    }
        -:  565:}
        -:  566:
        -:  567:/* TREE: Direct free (ASAP) */
function free_tree called 225 returned 100% blocks executed 59%
      225:  568:void free_tree(Obj* x) {
      225:  569:    if (!x) return;
branch  0 taken 2 (fallthrough)
branch  1 taken 223
      223:  570:    if (IS_IMMEDIATE(x)) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 222
     222*:  571:    if (is_stack_obj(x)) return;
call    0 returned 222
branch  1 taken 0 (fallthrough)
branch  2 taken 222
      222:  572:    switch (x->tag) {
branch  0 taken 108
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 114
      108:  573:    case TAG_PAIR:
      108:  574:        free_tree(x->a);
call    0 returned 108
      108:  575:        free_tree(x->b);
call    0 returned 108
      108:  576:        break;
    #####:  577:    case TAG_BOX:
    #####:  578:        if (x->ptr) free_tree((Obj*)x->ptr);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####:  579:        break;
    #####:  580:    case TAG_CLOSURE:
    #####:  581:        if (x->ptr) closure_release((Closure*)x->ptr);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####:  582:        break;
    #####:  583:    case TAG_SYM:
        -:  584:    case TAG_ERROR:
    #####:  585:        if (x->ptr) free(x->ptr);
branch  0 never executed (fallthrough)
branch  1 never executed
    #####:  586:        break;
      114:  587:    default:
      114:  588:        if (x->tag >= TAG_USER_BASE) {
branch  0 taken 0 (fallthrough)
branch  1 taken 114
    #####:  589:            release_user_obj(x);
call    0 never executed
        -:  590:        }
      114:  591:        break;
        -:  592:    }
      222:  593:    borrow_invalidate_obj(x);
call    0 returned 222
      222:  594:    invalidate_weak_refs_for(x);
call    0 returned 222
      222:  595:    free(x);
        -:  596:}
        -:  597:
        -:  598:/* DAG: Reference counting */
function dec_ref called 14354 returned 100% blocks executed 93%
    14354:  599:void dec_ref(Obj* x) {
    14354:  600:    if (!x) return;
branch  0 taken 172 (fallthrough)
branch  1 taken 14182
        -:  601:    /* Immediate integers don't need RC */
    14182:  602:    if (IS_IMMEDIATE(x)) return;
branch  0 taken 37 (fallthrough)
branch  1 taken 14145
    14145:  603:    if (is_stack_obj(x)) return;
call    0 returned 14145
branch  1 taken 1 (fallthrough)
branch  2 taken 14144
   14144*:  604:    if (x->mark < 0) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 14144
    14144:  605:    x->mark--;
    14144:  606:    if (x->mark <= 0) {
branch  0 taken 9757 (fallthrough)
branch  1 taken 4387
     9757:  607:        release_children(x);
call    0 returned 9757
     9757:  608:        borrow_invalidate_obj(x);
call    0 returned 9757
     9757:  609:        invalidate_weak_refs_for(x);
call    0 returned 9757
     9757:  610:        free(x);
        -:  611:    }
        -:  612:}
        -:  613:
function inc_ref called 4391 returned 100% blocks executed 91%
     4391:  614:void inc_ref(Obj* x) {
     4391:  615:    if (!x) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 4390
        -:  616:    /* Immediate integers don't need RC */
     4390:  617:    if (IS_IMMEDIATE(x)) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 4389
     4389:  618:    if (is_stack_obj(x)) return;
call    0 returned 4389
branch  1 taken 1 (fallthrough)
branch  2 taken 4388
    4388*:  619:    if (x->mark < 0) { x->mark = 1; return; }
branch  0 taken 0 (fallthrough)
branch  1 taken 4388
     4388:  620:    x->mark++;
        -:  621:}
        -:  622:
        -:  623:/* RC Optimization: Direct free for proven-unique references (Lobster-style) */
        -:  624:/* When compile-time analysis proves a reference is the only one, skip RC check */
function free_unique called 5 returned 100% blocks executed 92%
        5:  625:void free_unique(Obj* x) {
        5:  626:    if (!x) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        -:  627:    /* Immediate integers don't need freeing */
        4:  628:    if (IS_IMMEDIATE(x)) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 3
       3*:  629:    if (is_stack_obj(x)) return;
call    0 returned 3
branch  1 taken 0 (fallthrough)
branch  2 taken 3
        -:  630:    /* Proven unique at compile time - no RC check needed */
        3:  631:    release_children(x);
call    0 returned 3
        3:  632:    borrow_invalidate_obj(x);
call    0 returned 3
        3:  633:    invalidate_weak_refs_for(x);
call    0 returned 3
        3:  634:    free(x);
        -:  635:}
        -:  636:
        -:  637:/* RC Optimization: Borrowed reference - no RC ops needed */
        -:  638:/* For parameters and temporary references that don't transfer ownership */
        -:  639:#define BORROWED_REF(x) (x)  /* No-op marker for documentation */
        -:  640:
        -:  641:/* Free list operations */
function free_obj called 67 returned 100% blocks executed 69%
       67:  642:void free_obj(Obj* x) {
       67:  643:    if (!x) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 66
        -:  644:    /* Immediates don't need freeing */
       66:  645:    if (IS_IMMEDIATE(x)) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 65
      65*:  646:    if (is_stack_obj(x)) return;
call    0 returned 65
branch  1 taken 0 (fallthrough)
branch  2 taken 65
      65*:  647:    if (x->mark < 0) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 65
       65:  648:    x->mark = -1;
        -:  649:
        -:  650:    /* IPGE: Evolve generation to invalidate borrowed refs */
       65:  651:    x->generation = ipge_evolve(x->generation);
call    0 returned 65
        -:  652:
       65:  653:    FreeNode* n = malloc(sizeof(FreeNode));
       65:  654:    if (!n) {
branch  0 taken 0 (fallthrough)
branch  1 taken 65
    #####:  655:        release_children(x);
call    0 never executed
    #####:  656:        invalidate_weak_refs_for(x);
call    0 never executed
    #####:  657:        free(x);
    #####:  658:        return;
        -:  659:    }
       65:  660:    n->obj = x;
       65:  661:    n->next = FREE_HEAD;
       65:  662:    FREE_HEAD = n;
       65:  663:    FREE_COUNT++;
        -:  664:}
        -:  665:
function flush_freelist called 7 returned 100% blocks executed 100%
        7:  666:void flush_freelist(void) {
       70:  667:    while (FREE_HEAD) {
branch  0 taken 63
branch  1 taken 7 (fallthrough)
       63:  668:        FreeNode* n = FREE_HEAD;
       63:  669:        FREE_HEAD = n->next;
       63:  670:        if (n->obj->mark < 0) {
branch  0 taken 63 (fallthrough)
branch  1 taken 0
       63:  671:            release_children(n->obj);
call    0 returned 63
       63:  672:            borrow_invalidate_obj(n->obj);
call    0 returned 63
       63:  673:            invalidate_weak_refs_for(n->obj);
call    0 returned 63
       63:  674:            free(n->obj);
        -:  675:        }
       63:  676:        free(n);
        -:  677:    }
        7:  678:    FREE_COUNT = 0;
        7:  679:}
        -:  680:
        -:  681:/* Deferred release for cyclic structures */
function deferred_release called 0 returned 0% blocks executed 0%
    #####:  682:void deferred_release(Obj* x) {
    #####:  683:    free_obj(x);
call    0 never executed
    #####:  684:}
        -:  685:
        -:  686:/* Arena Allocator (Bulk Allocation/Deallocation) */
        -:  687:/* For cyclic data that doesn't escape function scope */
        -:  688:/* Enhanced with external pointer tracking */
        -:  689:
        -:  690:#define ARENA_BLOCK_SIZE 4096
        -:  691:
        -:  692:typedef struct ArenaBlock {
        -:  693:    char* memory;
        -:  694:    size_t size;
        -:  695:    size_t used;
        -:  696:    struct ArenaBlock* next;
        -:  697:} ArenaBlock;
        -:  698:
        -:  699:/* External pointer tracking - for pointers that escape the arena */
        -:  700:typedef struct ArenaExternal {
        -:  701:    void* ptr;
        -:  702:    void (*cleanup)(void*);
        -:  703:    struct ArenaExternal* next;
        -:  704:} ArenaExternal;
        -:  705:
        -:  706:typedef struct Arena {
        -:  707:    ArenaBlock* current;
        -:  708:    ArenaBlock* blocks;
        -:  709:    size_t block_size;
        -:  710:    ArenaExternal* externals;
        -:  711:} Arena;
        -:  712:
function arena_create called 27 returned 100% blocks executed 75%
       27:  713:Arena* arena_create(void) {
       27:  714:    Arena* a = malloc(sizeof(Arena));
      27*:  715:    if (!a) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 27
       27:  716:    a->current = NULL;
       27:  717:    a->blocks = NULL;
       27:  718:    a->block_size = ARENA_BLOCK_SIZE;
       27:  719:    a->externals = NULL;
       27:  720:    return a;
        -:  721:}
        -:  722:
function arena_alloc called 107601 returned 100% blocks executed 69%
   107601:  723:static void* arena_alloc(Arena* a, size_t size) {
  107601*:  724:    if (!a) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 107601
        -:  725:
        -:  726:    /* Align to 8 bytes */
   107601:  727:    size = (size + 7) & ~(size_t)7;
        -:  728:
   107601:  729:    if (!a->current || a->current->used + size > a->current->size) {
branch  0 taken 107581 (fallthrough)
branch  1 taken 20
branch  2 taken 952 (fallthrough)
branch  3 taken 106629
        -:  730:        /* Need new block */
      972:  731:        size_t block_size = a->block_size;
     972*:  732:        if (size > block_size) block_size = size;
branch  0 taken 0 (fallthrough)
branch  1 taken 972
        -:  733:
      972:  734:        ArenaBlock* b = malloc(sizeof(ArenaBlock));
     972*:  735:        if (!b) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 972
      972:  736:        b->memory = malloc(block_size);
      972:  737:        if (!b->memory) {
branch  0 taken 0 (fallthrough)
branch  1 taken 972
    #####:  738:            free(b);
    #####:  739:            return NULL;
        -:  740:        }
      972:  741:        b->size = block_size;
      972:  742:        b->used = 0;
      972:  743:        b->next = a->blocks;
      972:  744:        a->blocks = b;
      972:  745:        a->current = b;
        -:  746:    }
        -:  747:
   107601:  748:    void* ptr = a->current->memory + a->current->used;
   107601:  749:    a->current->used += size;
   107601:  750:    return ptr;
        -:  751:}
        -:  752:
        -:  753:/* Register an external pointer that must be cleaned up when arena is destroyed */
function arena_register_external called 7 returned 100% blocks executed 86%
        7:  754:void arena_register_external(Arena* a, void* ptr, void (*cleanup)(void*)) {
        7:  755:    if (!a || !ptr) return;
branch  0 taken 6 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 5
        5:  756:    ArenaExternal* e = malloc(sizeof(ArenaExternal));
       5*:  757:    if (!e) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        5:  758:    e->ptr = ptr;
        5:  759:    e->cleanup = cleanup;
        5:  760:    e->next = a->externals;
        5:  761:    a->externals = e;
        -:  762:}
        -:  763:
function arena_destroy called 28 returned 100% blocks executed 100%
       28:  764:void arena_destroy(Arena* a) {
       28:  765:    if (!a) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 27
        -:  766:
        -:  767:    /* Clean up external pointers first */
       27:  768:    ArenaExternal* e = a->externals;
       31:  769:    while (e) {
branch  0 taken 4
branch  1 taken 27 (fallthrough)
        4:  770:        ArenaExternal* next = e->next;
        4:  771:        if (e->cleanup) {
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4:  772:            e->cleanup(e->ptr);
call    0 returned 4
        -:  773:        }
        4:  774:        free(e);
        4:  775:        e = next;
        -:  776:    }
        -:  777:
        -:  778:    /* Free all blocks */
       27:  779:    ArenaBlock* b = a->blocks;
      999:  780:    while (b) {
branch  0 taken 972
branch  1 taken 27 (fallthrough)
      972:  781:        ArenaBlock* next = b->next;
      972:  782:        free(b->memory);
      972:  783:        free(b);
      972:  784:        b = next;
        -:  785:    }
        -:  786:
       27:  787:    free(a);
        -:  788:}
        -:  789:
        -:  790:/* Reset arena for reuse without destroying */
function arena_reset called 115 returned 100% blocks executed 100%
      115:  791:void arena_reset(Arena* a) {
      115:  792:    if (!a) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 114
        -:  793:
        -:  794:    /* Clean up externals */
      114:  795:    ArenaExternal* e = a->externals;
      115:  796:    while (e) {
branch  0 taken 1
branch  1 taken 114 (fallthrough)
        1:  797:        ArenaExternal* next = e->next;
        1:  798:        if (e->cleanup) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  799:            e->cleanup(e->ptr);
call    0 returned 1
        -:  800:        }
        1:  801:        free(e);
        1:  802:        e = next;
        -:  803:    }
      114:  804:    a->externals = NULL;
        -:  805:
        -:  806:    /* Reset all blocks */
      114:  807:    ArenaBlock* b = a->blocks;
      227:  808:    while (b) {
branch  0 taken 113
branch  1 taken 114 (fallthrough)
      113:  809:        b->used = 0;
      113:  810:        b = b->next;
        -:  811:    }
      114:  812:    a->current = a->blocks;
        -:  813:}
        -:  814:
function arena_mk_int called 91591 returned 100% blocks executed 83%
    91591:  815:Obj* arena_mk_int(Arena* a, long i) {
    91591:  816:    Obj* x = arena_alloc(a, sizeof(Obj));
call    0 returned 91591
   91591*:  817:    if (!x) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 91591
    91591:  818:    x->mark = -2;  /* Special mark for arena-allocated */
    91591:  819:    x->scc_id = -1;
    91591:  820:    x->is_pair = 0;
    91591:  821:    x->scan_tag = 0;
    91591:  822:    x->tag = TAG_INT;
    91591:  823:    x->generation = _next_generation();
call    0 returned 91591
    91591:  824:    x->i = i;
    91591:  825:    return x;
        -:  826:}
        -:  827:
function arena_mk_pair called 16010 returned 100% blocks executed 83%
    16010:  828:Obj* arena_mk_pair(Arena* a, Obj* car, Obj* cdr) {
    16010:  829:    Obj* x = arena_alloc(a, sizeof(Obj));
call    0 returned 16010
   16010*:  830:    if (!x) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 16010
    16010:  831:    x->mark = -2;  /* Special mark for arena-allocated */
    16010:  832:    x->scc_id = -1;
    16010:  833:    x->is_pair = 1;
    16010:  834:    x->scan_tag = 0;
    16010:  835:    x->tag = TAG_PAIR;
    16010:  836:    x->generation = _next_generation();
call    0 returned 16010
    16010:  837:    x->a = car;
    16010:  838:    x->b = cdr;
    16010:  839:    return x;
        -:  840:}
        -:  841:
        -:  842:/* SCC-Based Reference Counting (ISMM 2024) */
        -:  843:/* For frozen (deeply immutable) cyclic structures */
        -:  844:/* Uses Tarjan's algorithm for O(n) SCC detection */
        -:  845:
        -:  846:typedef struct SCC {
        -:  847:    int id;
        -:  848:    Obj** members;
        -:  849:    int member_count;
        -:  850:    int member_capacity;
        -:  851:    int ref_count;      /* Single RC for entire SCC */
        -:  852:    int frozen;         /* 1 if immutable */
        -:  853:    struct SCC* next;
        -:  854:} SCC;
        -:  855:
        -:  856:typedef struct SCCRegistry {
        -:  857:    SCC* sccs;
        -:  858:    int next_id;
        -:  859:} SCCRegistry;
        -:  860:
        -:  861:SCCRegistry SCC_REGISTRY = {NULL, 0};
        -:  862:
        -:  863:/* Tarjan's Algorithm state */
        -:  864:typedef struct TarjanState {
        -:  865:    int* index;
        -:  866:    int* lowlink;
        -:  867:    int* on_stack;
        -:  868:    Obj** stack;
        -:  869:    int stack_top;
        -:  870:    int current_index;
        -:  871:    int capacity;
        -:  872:} TarjanState;
        -:  873:
function tarjan_init called 108 returned 100% blocks executed 78%
      108:  874:static TarjanState* tarjan_init(int capacity) {
      108:  875:    TarjanState* s = malloc(sizeof(TarjanState));
     108*:  876:    if (!s) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 108
      108:  877:    s->index = calloc(capacity, sizeof(int));
      108:  878:    s->lowlink = calloc(capacity, sizeof(int));
      108:  879:    s->on_stack = calloc(capacity, sizeof(int));
      108:  880:    s->stack = malloc(capacity * sizeof(Obj*));
      108:  881:    s->stack_top = 0;
      108:  882:    s->current_index = 1;
      108:  883:    s->capacity = capacity;
      108:  884:    if (!s->index || !s->lowlink || !s->on_stack || !s->stack) {
branch  0 taken 108 (fallthrough)
branch  1 taken 0
branch  2 taken 108 (fallthrough)
branch  3 taken 0
branch  4 taken 108 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 108
    #####:  885:        free(s->index);
    #####:  886:        free(s->lowlink);
    #####:  887:        free(s->on_stack);
    #####:  888:        free(s->stack);
    #####:  889:        free(s);
    #####:  890:        return NULL;
        -:  891:    }
      108:  892:    return s;
        -:  893:}
        -:  894:
function tarjan_free called 109 returned 100% blocks executed 100%
      109:  895:void tarjan_free(TarjanState* s) {
      109:  896:    if (!s) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 108
      108:  897:    free(s->index);
      108:  898:    free(s->lowlink);
      108:  899:    free(s->on_stack);
      108:  900:    free(s->stack);
      108:  901:    free(s);
        -:  902:}
        -:  903:
function create_scc called 117 returned 100% blocks executed 75%
      117:  904:SCC* create_scc(void) {
      117:  905:    SCC* scc = malloc(sizeof(SCC));
     117*:  906:    if (!scc) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 117
      117:  907:    scc->id = SCC_REGISTRY.next_id++;
      117:  908:    scc->members = malloc(16 * sizeof(Obj*));
      117:  909:    scc->member_count = 0;
      117:  910:    scc->member_capacity = 16;
      117:  911:    scc->ref_count = 1;
      117:  912:    scc->frozen = 0;
      117:  913:    scc->next = SCC_REGISTRY.sccs;
      117:  914:    SCC_REGISTRY.sccs = scc;
      117:  915:    return scc;
        -:  916:}
        -:  917:
function scc_add_member called 2074 returned 100% blocks executed 89%
     2074:  918:void scc_add_member(SCC* scc, Obj* obj) {
     2074:  919:    if (!scc || !obj) return;
branch  0 taken 2073 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 2072
     2072:  920:    if (scc->member_count >= scc->member_capacity) {
branch  0 taken 8 (fallthrough)
branch  1 taken 2064
        8:  921:        int new_cap = scc->member_capacity * 2;
        8:  922:        Obj** new_members = realloc(scc->members, new_cap * sizeof(Obj*));
       8*:  923:        if (!new_members) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 8
        8:  924:        scc->members = new_members;
        8:  925:        scc->member_capacity = new_cap;
        -:  926:    }
     2072:  927:    scc->members[scc->member_count++] = obj;
     2072:  928:    obj->scc_id = scc->id;
        -:  929:}
        -:  930:
function freeze_scc called 118 returned 100% blocks executed 100%
      118:  931:void freeze_scc(SCC* scc) {
      118:  932:    if (scc) scc->frozen = 1;
branch  0 taken 117 (fallthrough)
branch  1 taken 1
      118:  933:}
        -:  934:
function find_scc called 8 returned 100% blocks executed 86%
        8:  935:SCC* find_scc(int id) {
        8:  936:    SCC* scc = SCC_REGISTRY.sccs;
        8:  937:    while (scc) {
branch  0 taken 5
branch  1 taken 3 (fallthrough)
        5:  938:        if (scc->id == id) return scc;
branch  0 taken 5 (fallthrough)
branch  1 taken 0
    #####:  939:        scc = scc->next;
        -:  940:    }
        3:  941:    return NULL;
        -:  942:}
        -:  943:
function release_scc called 119 returned 100% blocks executed 100%
      119:  944:void release_scc(SCC* scc) {
      119:  945:    if (!scc) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 118
      118:  946:    scc->ref_count--;
      118:  947:    if (scc->ref_count <= 0 && scc->frozen) {
branch  0 taken 118 (fallthrough)
branch  1 taken 0
branch  2 taken 117 (fallthrough)
branch  3 taken 1
        -:  948:        /* Free all members */
     2189:  949:        for (int i = 0; i < scc->member_count; i++) {
branch  0 taken 2072
branch  1 taken 117 (fallthrough)
     2072:  950:            Obj* obj = scc->members[i];
     2072:  951:            if (obj) {
branch  0 taken 2072 (fallthrough)
branch  1 taken 0
     2072:  952:                invalidate_weak_refs_for(obj);
call    0 returned 2072
     2072:  953:                free(obj);
        -:  954:            }
        -:  955:        }
      117:  956:        free(scc->members);
        -:  957:
        -:  958:        /* Remove from registry */
      117:  959:        SCC** pp = &SCC_REGISTRY.sccs;
     5070:  960:        while (*pp) {
branch  0 taken 5070
branch  1 taken 0 (fallthrough)
     5070:  961:            if (*pp == scc) {
branch  0 taken 117 (fallthrough)
branch  1 taken 4953
      117:  962:                *pp = scc->next;
      117:  963:                break;
        -:  964:            }
     4953:  965:            pp = &(*pp)->next;
        -:  966:        }
      117:  967:        free(scc);
        -:  968:    }
        -:  969:}
        -:  970:
        -:  971:/* Release object considering SCC membership */
function release_with_scc called 4 returned 100% blocks executed 100%
        4:  972:void release_with_scc(Obj* obj) {
        4:  973:    if (!obj) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        3:  974:    if (obj->scc_id >= 0) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:  975:        SCC* scc = find_scc(obj->scc_id);
call    0 returned 3
        3:  976:        if (scc) {
branch  0 taken 2 (fallthrough)
branch  1 taken 1
        2:  977:            release_scc(scc);
call    0 returned 2
        2:  978:            return;
        -:  979:        }
        -:  980:    }
        1:  981:    dec_ref(obj);
call    0 returned 1
        -:  982:}
        -:  983:
        -:  984:/* Tarjan's strongconnect for SCC detection */
function tarjan_strongconnect called 109 returned 100% blocks executed 97%
      109:  985:void tarjan_strongconnect(Obj* v, TarjanState* state,
        -:  986:                                  void (*on_scc)(Obj**, int)) {
      109:  987:    if (!v || !state) return;
branch  0 taken 108 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 108
        -:  988:
        -:  989:    /* Use scan_tag field to store Tarjan index for this node */
      108:  990:    int v_idx = state->current_index++;
      108:  991:    v->scan_tag = (unsigned int)v_idx;
      108:  992:    state->index[v_idx % state->capacity] = v_idx;
      108:  993:    state->lowlink[v_idx % state->capacity] = v_idx;
      108:  994:    state->stack[state->stack_top++] = v;
      108:  995:    state->on_stack[v_idx % state->capacity] = 1;
        -:  996:
        -:  997:    /* Visit children */
      108:  998:    if (v->is_pair) {
branch  0 taken 105 (fallthrough)
branch  1 taken 3
      105:  999:        Obj* children[] = {v->a, v->b};
      315: 1000:        for (int i = 0; i < 2; i++) {
branch  0 taken 210
branch  1 taken 105 (fallthrough)
      210: 1001:            Obj* w = children[i];
      210: 1002:            if (!w) continue;
branch  0 taken 2 (fallthrough)
branch  1 taken 208
        -: 1003:
      208: 1004:            int w_idx = (int)w->scan_tag;
      208: 1005:            if (w_idx == 0) {
branch  0 taken 3 (fallthrough)
branch  1 taken 205
        -: 1006:                /* Not visited yet */
        3: 1007:                tarjan_strongconnect(w, state, on_scc);
call    0 returned 3
        3: 1008:                int w_low = state->lowlink[w->scan_tag % state->capacity];
        3: 1009:                if (w_low < state->lowlink[v_idx % state->capacity]) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 1010:                    state->lowlink[v_idx % state->capacity] = w_low;
        -: 1011:                }
      205: 1012:            } else if (state->on_stack[w_idx % state->capacity]) {
branch  0 taken 200 (fallthrough)
branch  1 taken 5
        -: 1013:                /* w is on stack */
      200: 1014:                if (state->index[w_idx % state->capacity] < state->lowlink[v_idx % state->capacity]) {
branch  0 taken 1 (fallthrough)
branch  1 taken 199
        1: 1015:                    state->lowlink[v_idx % state->capacity] = state->index[w_idx % state->capacity];
        -: 1016:                }
        -: 1017:            }
        -: 1018:        }
        -: 1019:    }
        -: 1020:
        -: 1021:    /* Check if v is root of SCC */
      108: 1022:    if (state->lowlink[v_idx % state->capacity] == state->index[v_idx % state->capacity]) {
branch  0 taken 107 (fallthrough)
branch  1 taken 1
        -: 1023:        Obj* scc_members[256];
      107: 1024:        int scc_size = 0;
        -: 1025:        Obj* w;
        -: 1026:        do {
      108: 1027:            w = state->stack[--state->stack_top];
      108: 1028:            int w_idx = (int)w->scan_tag;
      108: 1029:            state->on_stack[w_idx % state->capacity] = 0;
      108: 1030:            if (scc_size < 256) {
branch  0 taken 108 (fallthrough)
branch  1 taken 0
      108: 1031:                scc_members[scc_size++] = w;
        -: 1032:            }
      108: 1033:        } while (w != v && state->stack_top > 0);
branch  0 taken 1 (fallthrough)
branch  1 taken 107
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        -: 1034:
      107: 1035:        if (scc_size > 1 && on_scc) {
branch  0 taken 1 (fallthrough)
branch  1 taken 106
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 1036:            on_scc(scc_members, scc_size);
call    0 returned 1
        -: 1037:        }
        -: 1038:    }
        -: 1039:}
        -: 1040:
function on_scc_found called 2 returned 100% blocks executed 88%
        2: 1041:void on_scc_found(Obj** members, int count) {
        2: 1042:    SCC* scc = create_scc();
call    0 returned 2
       2*: 1043:    if (!scc) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        7: 1044:    for (int i = 0; i < count; i++) {
branch  0 taken 5
branch  1 taken 2 (fallthrough)
        5: 1045:        scc_add_member(scc, members[i]);
call    0 returned 5
        -: 1046:    }
        -: 1047:}
        -: 1048:
        -: 1049:/* Detect and freeze SCCs starting from a root object */
function detect_and_freeze_sccs called 106 returned 100% blocks executed 91%
      106: 1050:void detect_and_freeze_sccs(Obj* root) {
      106: 1051:    TarjanState* state = tarjan_init(1024);
call    0 returned 106
     106*: 1052:    if (!state) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 106
      106: 1053:    tarjan_strongconnect(root, state, on_scc_found);
call    0 returned 106
        -: 1054:
        -: 1055:    /* Freeze all detected SCCs */
      106: 1056:    SCC* scc = SCC_REGISTRY.sccs;
      108: 1057:    while (scc) {
branch  0 taken 2
branch  1 taken 106 (fallthrough)
        2: 1058:        if (!scc->frozen) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 1059:            freeze_scc(scc);
call    0 returned 1
        -: 1060:        }
        2: 1061:        scc = scc->next;
        -: 1062:    }
        -: 1063:
      106: 1064:    tarjan_free(state);
call    0 returned 106
        -: 1065:}
        -: 1066:
        -: 1067:/* Deferred Reference Counting */
        -: 1068:/* For mutable cyclic structures - bounded O(k) processing per safe point */
        -: 1069:/* Based on Deutsch & Bobrow (1976) and CactusRef-style local detection */
        -: 1070:
        -: 1071:typedef struct DeferredDec {
        -: 1072:    Obj* obj;
        -: 1073:    int count;
        -: 1074:    struct DeferredDec* next;
        -: 1075:} DeferredDec;
        -: 1076:
        -: 1077:typedef struct DeferredContext {
        -: 1078:    DeferredDec* pending;
        -: 1079:    int pending_count;
        -: 1080:    int batch_size;     /* Max decrements per safe point */
        -: 1081:    int total_deferred;
        -: 1082:} DeferredContext;
        -: 1083:
        -: 1084:DeferredContext DEFERRED_CTX = {NULL, 0, 32, 0};
        -: 1085:
        -: 1086:/* O(1) deferral with coalescing */
function defer_decrement called 1997 returned 100% blocks executed 83%
     1997: 1087:void defer_decrement(Obj* obj) {
     1997: 1088:    if (!obj) return;
branch  0 taken 1 (fallthrough)
branch  1 taken 1996
     1996: 1089:    DEFERRED_CTX.total_deferred++;
        -: 1090:
        -: 1091:    /* Check if already in pending list - coalesce */
     1996: 1092:    DeferredDec* d = DEFERRED_CTX.pending;
   589849: 1093:    while (d) {
branch  0 taken 587956
branch  1 taken 1893 (fallthrough)
   587956: 1094:        if (d->obj == obj) {
branch  0 taken 103 (fallthrough)
branch  1 taken 587853
      103: 1095:            d->count++;
      103: 1096:            return;
        -: 1097:        }
   587853: 1098:        d = d->next;
        -: 1099:    }
        -: 1100:
        -: 1101:    /* Add new entry */
     1893: 1102:    DeferredDec* entry = malloc(sizeof(DeferredDec));
     1893: 1103:    if (!entry) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1893
        -: 1104:        /* Fallback: immediate decrement */
    #####: 1105:        dec_ref(obj);
call    0 never executed
    #####: 1106:        return;
        -: 1107:    }
     1893: 1108:    entry->obj = obj;
     1893: 1109:    entry->count = 1;
     1893: 1110:    entry->next = DEFERRED_CTX.pending;
     1893: 1111:    DEFERRED_CTX.pending = entry;
     1893: 1112:    DEFERRED_CTX.pending_count++;
        -: 1113:}
        -: 1114:
        -: 1115:/* Process up to batch_size decrements - bounded work */
function process_deferred called 34 returned 100% blocks executed 93%
       34: 1116:void process_deferred(void) {
       34: 1117:    int processed = 0;
      717: 1118:    while (DEFERRED_CTX.pending && processed < DEFERRED_CTX.batch_size) {
branch  0 taken 714 (fallthrough)
branch  1 taken 3
branch  2 taken 683
branch  3 taken 31 (fallthrough)
      683: 1119:        DeferredDec* d = DEFERRED_CTX.pending;
      683: 1120:        DEFERRED_CTX.pending = d->next;
      683: 1121:        DEFERRED_CTX.pending_count--;
        -: 1122:
        -: 1123:        /* Apply decrements */
     1334: 1124:        while (d->count > 0) {
branch  0 taken 683
branch  1 taken 651 (fallthrough)
      683: 1125:            dec_ref(d->obj);
call    0 returned 683
      683: 1126:            d->count--;
      683: 1127:            processed++;
      683: 1128:            if (processed >= DEFERRED_CTX.batch_size) break;
branch  0 taken 32 (fallthrough)
branch  1 taken 651
        -: 1129:        }
        -: 1130:
      683: 1131:        if (d->count > 0) {
branch  0 taken 0 (fallthrough)
branch  1 taken 683
        -: 1132:            /* Put back for next round */
    #####: 1133:            d->next = DEFERRED_CTX.pending;
    #####: 1134:            DEFERRED_CTX.pending = d;
    #####: 1135:            DEFERRED_CTX.pending_count++;
        -: 1136:        } else {
      683: 1137:            free(d);
        -: 1138:        }
        -: 1139:    }
       34: 1140:}
        -: 1141:
        -: 1142:/* Check if we should process deferred decrements */
function should_process_deferred called 17 returned 100% blocks executed 100%
       17: 1143:int should_process_deferred(void) {
       17: 1144:    return DEFERRED_CTX.pending_count > DEFERRED_CTX.batch_size * 2;
        -: 1145:}
        -: 1146:
        -: 1147:/* Flush all pending decrements */
function flush_deferred called 134 returned 100% blocks executed 100%
      134: 1148:void flush_deferred(void) {
     1344: 1149:    while (DEFERRED_CTX.pending) {
branch  0 taken 1210
branch  1 taken 134 (fallthrough)
     1210: 1150:        DeferredDec* d = DEFERRED_CTX.pending;
     1210: 1151:        DEFERRED_CTX.pending = d->next;
        -: 1152:
     2523: 1153:        while (d->count > 0) {
branch  0 taken 1313
branch  1 taken 1210 (fallthrough)
     1313: 1154:            dec_ref(d->obj);
call    0 returned 1313
     1313: 1155:            d->count--;
        -: 1156:        }
     1210: 1157:        free(d);
        -: 1158:    }
      134: 1159:    DEFERRED_CTX.pending_count = 0;
      134: 1160:}
        -: 1161:
        -: 1162:/* Safe point: check and maybe process deferred - call at function boundaries */
function safe_point called 15 returned 100% blocks executed 100%
       15: 1163:void safe_point(void) {
       15: 1164:    if (should_process_deferred()) {
call    0 returned 15
branch  1 taken 11 (fallthrough)
branch  2 taken 4
       11: 1165:        process_deferred();
call    0 returned 11
        -: 1166:    }
       15: 1167:}
        -: 1168:
        -: 1169:/* Set batch size for tuning */
function set_deferred_batch_size called 13 returned 100% blocks executed 100%
       13: 1170:void set_deferred_batch_size(int size) {
       13: 1171:    if (size > 0) {
branch  0 taken 11 (fallthrough)
branch  1 taken 2
       11: 1172:        DEFERRED_CTX.batch_size = size;
        -: 1173:    }
       13: 1174:}
        -: 1175:
        -: 1176:/* Symmetric Reference Counting (Hybrid Memory Strategy) */
        -: 1177:/* Key insight: Treat scope as an object that participates in ownership graph */
        -: 1178:/* External refs: From live scopes/roots */
        -: 1179:/* Internal refs: Within the object graph */
        -: 1180:/* When external_rc drops to 0, the object (or cycle) is orphaned garbage */
        -: 1181:
        -: 1182:typedef struct SymObj SymObj;
        -: 1183:typedef struct SymScope SymScope;
        -: 1184:
        -: 1185:struct SymObj {
        -: 1186:    int external_rc;      /* References from live scopes */
        -: 1187:    int internal_rc;      /* References from other objects */
        -: 1188:    SymObj** refs;        /* Objects this object references */
        -: 1189:    int ref_count;        /* Number of outgoing references */
        -: 1190:    int ref_capacity;
        -: 1191:    void* data;           /* Actual data payload (Obj*) */
        -: 1192:    int freed;            /* Mark to prevent double-free */
        -: 1193:};
        -: 1194:
        -: 1195:struct SymScope {
        -: 1196:    SymObj** owned;       /* Objects owned by this scope */
        -: 1197:    int owned_count;
        -: 1198:    int owned_capacity;
        -: 1199:    SymScope* parent;
        -: 1200:};
        -: 1201:
        -: 1202:/* Global symmetric RC context */
        -: 1203:static struct {
        -: 1204:    SymScope* current;
        -: 1205:    SymScope** stack;
        -: 1206:    int stack_size;
        -: 1207:    int stack_capacity;
        -: 1208:    int objects_created;
        -: 1209:    int cycles_collected;
        -: 1210:} SYM_CTX = {NULL, NULL, 0, 0, 0, 0};
        -: 1211:
        -: 1212:/* Forward declarations */
        -: 1213:void sym_check_free(SymObj* obj);
        -: 1214:
function sym_obj_new called 0 returned 0% blocks executed 0%
    #####: 1215:SymObj* sym_obj_new(void* data) {
    #####: 1216:    SymObj* obj = malloc(sizeof(SymObj));
    #####: 1217:    if (!obj) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1218:    obj->external_rc = 0;
    #####: 1219:    obj->internal_rc = 0;
    #####: 1220:    obj->refs = NULL;
    #####: 1221:    obj->ref_count = 0;
    #####: 1222:    obj->ref_capacity = 0;
    #####: 1223:    obj->data = data;
    #####: 1224:    obj->freed = 0;
    #####: 1225:    return obj;
        -: 1226:}
        -: 1227:
function sym_obj_add_ref called 0 returned 0% blocks executed 0%
    #####: 1228:void sym_obj_add_ref(SymObj* obj, SymObj* target) {
    #####: 1229:    if (!obj || !target) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1230:    if (obj->ref_count >= obj->ref_capacity) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1231:        int new_cap = obj->ref_capacity == 0 ? 8 : obj->ref_capacity * 2;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1232:        SymObj** new_refs = realloc(obj->refs, new_cap * sizeof(SymObj*));
    #####: 1233:        if (!new_refs) return;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1234:        obj->refs = new_refs;
    #####: 1235:        obj->ref_capacity = new_cap;
        -: 1236:    }
    #####: 1237:    obj->refs[obj->ref_count++] = target;
        -: 1238:}
        -: 1239:
function sym_scope_new called 0 returned 0% blocks executed 0%
    #####: 1240:SymScope* sym_scope_new(SymScope* parent) {
    #####: 1241:    SymScope* scope = malloc(sizeof(SymScope));
    #####: 1242:    if (!scope) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1243:    scope->owned = NULL;
    #####: 1244:    scope->owned_count = 0;
    #####: 1245:    scope->owned_capacity = 0;
    #####: 1246:    scope->parent = parent;
    #####: 1247:    return scope;
        -: 1248:}
        -: 1249:
function sym_scope_own called 0 returned 0% blocks executed 0%
    #####: 1250:void sym_scope_own(SymScope* scope, SymObj* obj) {
    #####: 1251:    if (!scope || !obj || obj->freed) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1252:    if (scope->owned_count >= scope->owned_capacity) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1253:        int new_cap = scope->owned_capacity == 0 ? 8 : scope->owned_capacity * 2;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1254:        SymObj** new_owned = realloc(scope->owned, new_cap * sizeof(SymObj*));
    #####: 1255:        if (!new_owned) return;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1256:        scope->owned = new_owned;
    #####: 1257:        scope->owned_capacity = new_cap;
        -: 1258:    }
    #####: 1259:    obj->external_rc++;
    #####: 1260:    scope->owned[scope->owned_count++] = obj;
        -: 1261:}
        -: 1262:
function sym_dec_external called 0 returned 0% blocks executed 0%
    #####: 1263:void sym_dec_external(SymObj* obj) {
    #####: 1264:    if (!obj || obj->freed) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1265:    obj->external_rc--;
    #####: 1266:    sym_check_free(obj);
call    0 never executed
        -: 1267:}
        -: 1268:
function sym_dec_internal called 0 returned 0% blocks executed 0%
    #####: 1269:void sym_dec_internal(SymObj* obj) {
    #####: 1270:    if (!obj || obj->freed) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1271:    obj->internal_rc--;
    #####: 1272:    sym_check_free(obj);
call    0 never executed
        -: 1273:}
        -: 1274:
function sym_check_free called 0 returned 0% blocks executed 0%
    #####: 1275:void sym_check_free(SymObj* obj) {
    #####: 1276:    if (!obj || obj->freed) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 1277:    /* Object is garbage when it has no external references */
    #####: 1278:    if (obj->external_rc <= 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1279:        obj->freed = 1;
        -: 1280:        /* Cascade: decrement internal refs for all objects we reference */
    #####: 1281:        for (int i = 0; i < obj->ref_count; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1282:            sym_dec_internal(obj->refs[i]);
call    0 never executed
        -: 1283:        }
        -: 1284:        /* Free the data (Obj*) if present */
    #####: 1285:        if (obj->data) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1286:            dec_ref((Obj*)obj->data);
call    0 never executed
        -: 1287:        }
    #####: 1288:        free(obj->refs);
    #####: 1289:        free(obj);
        -: 1290:    }
        -: 1291:}
        -: 1292:
function sym_scope_release called 0 returned 0% blocks executed 0%
    #####: 1293:void sym_scope_release(SymScope* scope) {
    #####: 1294:    if (!scope) return;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1295:    for (int i = 0; i < scope->owned_count; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1296:        sym_dec_external(scope->owned[i]);
call    0 never executed
        -: 1297:    }
    #####: 1298:    scope->owned_count = 0;
        -: 1299:}
        -: 1300:
function sym_scope_free called 0 returned 0% blocks executed 0%
    #####: 1301:void sym_scope_free(SymScope* scope) {
    #####: 1302:    if (!scope) return;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1303:    free(scope->owned);
    #####: 1304:    free(scope);
        -: 1305:}
        -: 1306:
        -: 1307:/* Context operations */
function sym_init called 0 returned 0% blocks executed 0%
    #####: 1308:void sym_init(void) {
    #####: 1309:    if (SYM_CTX.current) return;  /* Already initialized */
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1310:    SYM_CTX.current = sym_scope_new(NULL);
call    0 never executed
    #####: 1311:    SYM_CTX.stack = malloc(8 * sizeof(SymScope*));
    #####: 1312:    SYM_CTX.stack[0] = SYM_CTX.current;
    #####: 1313:    SYM_CTX.stack_size = 1;
    #####: 1314:    SYM_CTX.stack_capacity = 8;
        -: 1315:}
        -: 1316:
function sym_enter_scope called 0 returned 0% blocks executed 0%
    #####: 1317:SymScope* sym_enter_scope(void) {
    #####: 1318:    if (!SYM_CTX.current) sym_init();
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 1319:    SymScope* scope = sym_scope_new(SYM_CTX.current);
call    0 never executed
    #####: 1320:    if (!scope) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1321:    if (SYM_CTX.stack_size >= SYM_CTX.stack_capacity) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1322:        int new_cap = SYM_CTX.stack_capacity * 2;
    #####: 1323:        SymScope** new_stack = realloc(SYM_CTX.stack, new_cap * sizeof(SymScope*));
    #####: 1324:        if (!new_stack) { sym_scope_free(scope); return NULL; }
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 1325:        SYM_CTX.stack = new_stack;
    #####: 1326:        SYM_CTX.stack_capacity = new_cap;
        -: 1327:    }
    #####: 1328:    SYM_CTX.stack[SYM_CTX.stack_size++] = scope;
    #####: 1329:    SYM_CTX.current = scope;
    #####: 1330:    return scope;
        -: 1331:}
        -: 1332:
function sym_exit_scope called 0 returned 0% blocks executed 0%
    #####: 1333:void sym_exit_scope(void) {
    #####: 1334:    if (SYM_CTX.stack_size <= 1) return;  /* Don't exit global */
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1335:    SymScope* scope = SYM_CTX.stack[--SYM_CTX.stack_size];
    #####: 1336:    SYM_CTX.current = SYM_CTX.stack[SYM_CTX.stack_size - 1];
        -: 1337:    /* Count cycles for stats */
    #####: 1338:    for (int i = 0; i < scope->owned_count; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1339:        SymObj* obj = scope->owned[i];
    #####: 1340:        if (obj && !obj->freed && obj->internal_rc > 0 && obj->external_rc == 1) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
branch  6 never executed (fallthrough)
branch  7 never executed
    #####: 1341:            SYM_CTX.cycles_collected++;
        -: 1342:        }
        -: 1343:    }
    #####: 1344:    sym_scope_release(scope);
call    0 never executed
    #####: 1345:    sym_scope_free(scope);
call    0 never executed
        -: 1346:}
        -: 1347:
        -: 1348:/* Allocate object in current scope */
function sym_alloc called 0 returned 0% blocks executed 0%
    #####: 1349:SymObj* sym_alloc(Obj* data) {
    #####: 1350:    if (!SYM_CTX.current) sym_init();
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 1351:    SymObj* obj = sym_obj_new(data);
call    0 never executed
    #####: 1352:    if (!obj) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1353:    sym_scope_own(SYM_CTX.current, obj);
call    0 never executed
    #####: 1354:    SYM_CTX.objects_created++;
    #####: 1355:    return obj;
        -: 1356:}
        -: 1357:
        -: 1358:/* Create internal reference (from one object to another) */
function sym_link called 0 returned 0% blocks executed 0%
    #####: 1359:void sym_link(SymObj* from, SymObj* to) {
    #####: 1360:    if (!from || !to || to->freed) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 1361:    to->internal_rc++;
    #####: 1362:    sym_obj_add_ref(from, to);
call    0 never executed
        -: 1363:}
        -: 1364:
        -: 1365:/* Get the Obj* from a SymObj* */
function sym_get_data called 0 returned 0% blocks executed 0%
    #####: 1366:Obj* sym_get_data(SymObj* obj) {
    #####: 1367:    return obj ? (Obj*)obj->data : NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371:/* ========== Region References (v0.5.0) ========== */
        -: 1372:/* Vale/Ada/SPARK-style scope hierarchy validation */
        -: 1373:/* O(1) CanReference check via depth comparison */
        -: 1374:
        -: 1375:typedef uint64_t RegionID;
        -: 1376:typedef uint32_t RegionDepth;
        -: 1377:
        -: 1378:typedef struct Region Region;
        -: 1379:typedef struct RegionObj RegionObj;
        -: 1380:typedef struct RegionRef RegionRef;
        -: 1381:typedef struct RegionContext RegionContext;
        -: 1382:
        -: 1383:struct Region {
        -: 1384:    RegionID id;
        -: 1385:    RegionDepth depth;
        -: 1386:    Region* parent;
        -: 1387:    Region** children;
        -: 1388:    int child_count;
        -: 1389:    int child_capacity;
        -: 1390:    RegionObj** objects;
        -: 1391:    int object_count;
        -: 1392:    int object_capacity;
        -: 1393:    int closed;
        -: 1394:};
        -: 1395:
        -: 1396:struct RegionObj {
        -: 1397:    Region* region;
        -: 1398:    void* data;
        -: 1399:    void (*destructor)(void*);
        -: 1400:};
        -: 1401:
        -: 1402:struct RegionRef {
        -: 1403:    RegionObj* target;
        -: 1404:    Region* source_region;
        -: 1405:};
        -: 1406:
        -: 1407:struct RegionContext {
        -: 1408:    Region* root;
        -: 1409:    Region* current;
        -: 1410:    uint64_t next_id;
        -: 1411:};
        -: 1412:
        -: 1413:/* Global context (can also use explicit context) */
        -: 1414:static RegionContext* g_region_ctx = NULL;
        -: 1415:
function region_new called 0 returned 0% blocks executed 0%
    #####: 1416:static Region* region_new(Region* parent, uint64_t* next_id) {
    #####: 1417:    Region* r = calloc(1, sizeof(Region));
    #####: 1418:    if (!r) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1419:    r->id = (*next_id)++;
    #####: 1420:    r->depth = parent ? parent->depth + 1 : 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1421:    r->parent = parent;
    #####: 1422:    r->closed = 0;
    #####: 1423:    return r;
        -: 1424:}
        -: 1425:
function region_context_new called 0 returned 0% blocks executed 0%
    #####: 1426:static RegionContext* region_context_new(void) {
    #####: 1427:    RegionContext* ctx = calloc(1, sizeof(RegionContext));
    #####: 1428:    if (!ctx) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1429:    ctx->next_id = 1;
    #####: 1430:    ctx->root = region_new(NULL, &ctx->next_id);
call    0 never executed
    #####: 1431:    ctx->current = ctx->root;
    #####: 1432:    return ctx;
        -: 1433:}
        -: 1434:
function region_init called 0 returned 0% blocks executed 0%
    #####: 1435:void region_init(void) {
    #####: 1436:    if (!g_region_ctx) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1437:        g_region_ctx = region_context_new();
call    0 never executed
        -: 1438:    }
    #####: 1439:}
        -: 1440:
function region_enter called 0 returned 0% blocks executed 0%
    #####: 1441:static Region* region_enter(void) {
    #####: 1442:    region_init();
call    0 never executed
    #####: 1443:    Region* child = region_new(g_region_ctx->current, &g_region_ctx->next_id);
call    0 never executed
    #####: 1444:    if (!child) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1445:
    #####: 1446:    Region* parent = g_region_ctx->current;
    #####: 1447:    if (parent->child_count >= parent->child_capacity) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1448:        int new_cap = parent->child_capacity == 0 ? 4 : parent->child_capacity * 2;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1449:        Region** new_children = realloc(parent->children, new_cap * sizeof(Region*));
    #####: 1450:        if (!new_children) { free(child); return NULL; }
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1451:        parent->children = new_children;
    #####: 1452:        parent->child_capacity = new_cap;
        -: 1453:    }
    #####: 1454:    parent->children[parent->child_count++] = child;
    #####: 1455:    g_region_ctx->current = child;
    #####: 1456:    return child;
        -: 1457:}
        -: 1458:
function region_exit called 0 returned 0% blocks executed 0%
    #####: 1459:int region_exit(void) {
    #####: 1460:    if (!g_region_ctx || !g_region_ctx->current) return -1;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1461:    if (g_region_ctx->current == g_region_ctx->root) return -1;  /* Cannot exit root */
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1462:
    #####: 1463:    Region* exiting = g_region_ctx->current;
    #####: 1464:    exiting->closed = 1;
        -: 1465:
        -: 1466:    /* Invalidate all objects in this region */
    #####: 1467:    for (int i = 0; i < exiting->object_count; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1468:        RegionObj* obj = exiting->objects[i];
    #####: 1469:        if (obj) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1470:            if (obj->destructor && obj->data) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1471:                obj->destructor(obj->data);
call    0 never executed
        -: 1472:            }
    #####: 1473:            obj->region = NULL;  /* Mark as invalid */
        -: 1474:        }
        -: 1475:    }
    #####: 1476:    g_region_ctx->current = exiting->parent;
    #####: 1477:    return 0;
        -: 1478:}
        -: 1479:
function region_alloc called 0 returned 0% blocks executed 0%
    #####: 1480:static RegionObj* region_alloc(void* data, void (*destructor)(void*)) {
    #####: 1481:    region_init();
call    0 never executed
    #####: 1482:    RegionObj* obj = calloc(1, sizeof(RegionObj));
    #####: 1483:    if (!obj) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1484:    obj->region = g_region_ctx->current;
    #####: 1485:    obj->data = data;
    #####: 1486:    obj->destructor = destructor;
        -: 1487:
    #####: 1488:    Region* r = g_region_ctx->current;
    #####: 1489:    if (r->object_count >= r->object_capacity) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1490:        int new_cap = r->object_capacity == 0 ? 8 : r->object_capacity * 2;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1491:        RegionObj** new_objs = realloc(r->objects, new_cap * sizeof(RegionObj*));
    #####: 1492:        if (!new_objs) { free(obj); return NULL; }
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1493:        r->objects = new_objs;
    #####: 1494:        r->object_capacity = new_cap;
        -: 1495:    }
    #####: 1496:    r->objects[r->object_count++] = obj;
    #####: 1497:    return obj;
        -: 1498:}
        -: 1499:
        -: 1500:/* O(1) check: inner can reference outer (depth >= target depth) */
function region_can_reference called 0 returned 0% blocks executed 0%
    #####: 1501:int region_can_reference(RegionObj* source, RegionObj* target) {
    #####: 1502:    if (!source || !target) return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1503:    if (!source->region || !target->region) return 0;  /* Invalid objects */
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1504:    return source->region->depth >= target->region->depth;
        -: 1505:}
        -: 1506:
function region_create_ref called 0 returned 0% blocks executed 0%
    #####: 1507:static RegionRef* region_create_ref(RegionObj* source, RegionObj* target) {
    #####: 1508:    if (!region_can_reference(source, target)) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1509:        fprintf(stderr, "region: scope violation - inner cannot hold ref to outer\n");
call    0 never executed
    #####: 1510:        return NULL;
        -: 1511:    }
    #####: 1512:    RegionRef* ref = calloc(1, sizeof(RegionRef));
    #####: 1513:    if (!ref) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1514:    ref->target = target;
    #####: 1515:    ref->source_region = source->region;
    #####: 1516:    return ref;
        -: 1517:}
        -: 1518:
function region_ref_is_valid called 0 returned 0% blocks executed 0%
    #####: 1519:int region_ref_is_valid(RegionRef* ref) {
    #####: 1520:    return ref && ref->target && ref->target->region != NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
        -: 1521:}
        -: 1522:
function region_deref called 0 returned 0% blocks executed 0%
    #####: 1523:static void* region_deref(RegionRef* ref) {
    #####: 1524:    if (!region_ref_is_valid(ref)) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1525:        fprintf(stderr, "region: use-after-free or scope violation\n");
call    0 never executed
    #####: 1526:        return NULL;
        -: 1527:    }
    #####: 1528:    return ref->target->data;
        -: 1529:}
        -: 1530:
        -: 1531:
        -: 1532:/* ========== Random Generational References (v0.5.0) ========== */
        -: 1533:/* Vale-style use-after-free detection */
        -: 1534:/* Thread-safe via pthread_rwlock (C99 + POSIX) */
        -: 1535:/*
        -: 1536: * NOTE: This is the LEGACY system using heap-allocated BorrowRef structs.
        -: 1537: * The new IPGE system uses packed 64-bit BorrowedRef (see purple.h).
        -: 1538: * This legacy code is kept for compatibility but IPGE is preferred.
        -: 1539: */
        -: 1540:
        -: 1541:#include <time.h>
        -: 1542:
        -: 1543:/* Legacy uses 64-bit generation regardless of IPGE mode */
        -: 1544:typedef uint64_t LegacyGeneration;
        -: 1545:
        -: 1546:/* GenObj and GenClosure are only used by legacy code paths */
        -: 1547:typedef struct GenClosure GenClosure;
        -: 1548:typedef struct LegacyGenContext LegacyGenContext;
        -: 1549:
        -: 1550:struct GenObj {
        -: 1551:    LegacyGeneration generation;
        -: 1552:    void* data;
        -: 1553:    void (*destructor)(void*);
        -: 1554:    int freed;
        -: 1555:    pthread_rwlock_t rwlock;
        -: 1556:};
        -: 1557:
        -: 1558:/* BorrowRef is defined in forward declarations section above */
        -: 1559:
        -: 1560:/* Closure with capture validation */
        -: 1561:struct GenClosure {
        -: 1562:    BorrowRef** captures;
        -: 1563:    int capture_count;
        -: 1564:    void* (*func)(void* ctx);
        -: 1565:    void* ctx;
        -: 1566:};
        -: 1567:
        -: 1568:struct LegacyGenContext {
        -: 1569:    GenObj** objects;
        -: 1570:    int object_count;
        -: 1571:    int object_capacity;
        -: 1572:    pthread_mutex_t mutex;
        -: 1573:};
        -: 1574:
        -: 1575:static LegacyGenContext* g_legacy_ctx = NULL;
        -: 1576:
        -: 1577:/* Fast xorshift64 PRNG for legacy generation IDs */
function legacy_random_gen called 0 returned 0% blocks executed 0%
    #####: 1578:static LegacyGeneration legacy_random_gen(void) {
        -: 1579:    static uint64_t state = 0;
        -: 1580:    static pthread_mutex_t prng_mutex = PTHREAD_MUTEX_INITIALIZER;
    #####: 1581:    pthread_mutex_lock(&prng_mutex);
call    0 never executed
    #####: 1582:    if (state == 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1583:        state = (uint64_t)time(NULL) ^ 0x9e3779b97f4a7c15ULL;
call    0 never executed
        -: 1584:    }
    #####: 1585:    state ^= state << 13;
    #####: 1586:    state ^= state >> 7;
    #####: 1587:    state ^= state << 17;
    #####: 1588:    LegacyGeneration result = state ? state : 1;  /* Never return 0 */
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1589:    pthread_mutex_unlock(&prng_mutex);
call    0 never executed
    #####: 1590:    return result;
        -: 1591:}
        -: 1592:
function legacy_context_new called 0 returned 0% blocks executed 0%
    #####: 1593:static LegacyGenContext* legacy_context_new(void) {
    #####: 1594:    LegacyGenContext* ctx = calloc(1, sizeof(LegacyGenContext));
    #####: 1595:    if (ctx) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1596:        pthread_mutex_init(&ctx->mutex, NULL);
call    0 never executed
        -: 1597:    }
    #####: 1598:    return ctx;
        -: 1599:}
        -: 1600:
function legacy_init called 0 returned 0% blocks executed 0%
    #####: 1601:void legacy_init(void) {
    #####: 1602:    if (!g_legacy_ctx) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1603:        g_legacy_ctx = legacy_context_new();
call    0 never executed
        -: 1604:    }
    #####: 1605:}
        -: 1606:
function legacy_alloc called 0 returned 0% blocks executed 0%
    #####: 1607:static GenObj* legacy_alloc(LegacyGenContext* ctx, void* data, void (*destructor)(void*)) {
    #####: 1608:    GenObj* obj = calloc(1, sizeof(GenObj));
    #####: 1609:    if (!obj) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1610:    obj->generation = legacy_random_gen();
call    0 never executed
    #####: 1611:    obj->data = data;
    #####: 1612:    obj->destructor = destructor;
    #####: 1613:    obj->freed = 0;
    #####: 1614:    pthread_rwlock_init(&obj->rwlock, NULL);
call    0 never executed
        -: 1615:
    #####: 1616:    if (ctx) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1617:        pthread_mutex_lock(&ctx->mutex);
call    0 never executed
    #####: 1618:        if (ctx->object_count >= ctx->object_capacity) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1619:            int new_cap = ctx->object_capacity == 0 ? 16 : ctx->object_capacity * 2;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1620:            GenObj** new_objs = realloc(ctx->objects, new_cap * sizeof(GenObj*));
    #####: 1621:            if (new_objs) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1622:                ctx->objects = new_objs;
    #####: 1623:                ctx->object_capacity = new_cap;
        -: 1624:            }
        -: 1625:        }
    #####: 1626:        if (ctx->object_count < ctx->object_capacity) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1627:            ctx->objects[ctx->object_count++] = obj;
        -: 1628:        }
    #####: 1629:        pthread_mutex_unlock(&ctx->mutex);
call    0 never executed
        -: 1630:    }
    #####: 1631:    return obj;
        -: 1632:}
        -: 1633:
function legacy_free called 0 returned 0% blocks executed 0%
    #####: 1634:void legacy_free(GenObj* obj) {
    #####: 1635:    if (!obj) return;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1636:    pthread_rwlock_wrlock(&obj->rwlock);
call    0 never executed
    #####: 1637:    if (obj->freed) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1638:        pthread_rwlock_unlock(&obj->rwlock);
call    0 never executed
    #####: 1639:        return;
        -: 1640:    }
    #####: 1641:    obj->generation = 0;  /* Invalidate ALL references instantly */
    #####: 1642:    obj->freed = 1;
    #####: 1643:    if (obj->destructor && obj->data) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1644:        obj->destructor(obj->data);
call    0 never executed
        -: 1645:    }
    #####: 1646:    obj->data = NULL;
    #####: 1647:    pthread_rwlock_unlock(&obj->rwlock);
call    0 never executed
    #####: 1648:    pthread_rwlock_destroy(&obj->rwlock);
call    0 never executed
        -: 1649:}
        -: 1650:
function borrow_release called 1121 returned 100% blocks executed 100%
     1121: 1651:void borrow_release(BorrowRef* ref) {
     1121: 1652:    if (ref) free(ref);
branch  0 taken 1120 (fallthrough)
branch  1 taken 1
     1121: 1653:}
        -: 1654:
function legacy_create called 0 returned 0% blocks executed 0%
    #####: 1655:BorrowRef* legacy_create(GenObj* obj, const char* source_desc) {
    #####: 1656:    if (!obj) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1657:    pthread_rwlock_rdlock(&obj->rwlock);
call    0 never executed
    #####: 1658:    if (obj->freed || obj->generation == 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1659:        pthread_rwlock_unlock(&obj->rwlock);
call    0 never executed
    #####: 1660:        return NULL;
        -: 1661:    }
    #####: 1662:    BorrowRef* ref = calloc(1, sizeof(BorrowRef));
    #####: 1663:    if (!ref) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1664:        pthread_rwlock_unlock(&obj->rwlock);
call    0 never executed
    #####: 1665:        return NULL;
        -: 1666:    }
    #####: 1667:    ref->target = obj;
    #####: 1668:    ref->remembered_gen = obj->generation;
    #####: 1669:    ref->source_desc = source_desc;
    #####: 1670:    pthread_rwlock_unlock(&obj->rwlock);
call    0 never executed
    #####: 1671:    return ref;
        -: 1672:}
        -: 1673:
        -: 1674:/* O(1) validity check - IPGE generation comparison */
function borrow_is_valid called 1229 returned 100% blocks executed 50%
     1229: 1675:int borrow_is_valid(BorrowRef* ref) {
     1229: 1676:    if (!ref) return 0;
branch  0 taken 1 (fallthrough)
branch  1 taken 1228
        -: 1677:    /* IPGE mode: use ipge_target */
     1228: 1678:    if (ref->ipge_target) {
branch  0 taken 1228 (fallthrough)
branch  1 taken 0
        -: 1679:        /* Compare remembered generation with current generation */
     2342: 1680:        return ref->remembered_gen == ref->ipge_target->generation &&
branch  0 taken 1114 (fallthrough)
branch  1 taken 114
     1114: 1681:               ref->ipge_target->generation != 0;
branch  0 taken 1114 (fallthrough)
branch  1 taken 0
        -: 1682:    }
        -: 1683:    /* Legacy GenObj mode */
    #####: 1684:    if (!ref->target) return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1685:    pthread_rwlock_rdlock(&ref->target->rwlock);
call    0 never executed
    #####: 1686:    int valid = ref->remembered_gen == ref->target->generation &&
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1687:                ref->target->generation != 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1688:    pthread_rwlock_unlock(&ref->target->rwlock);
call    0 never executed
    #####: 1689:    return valid;
        -: 1690:}
        -: 1691:
function borrow_deref called 0 returned 0% blocks executed 0%
    #####: 1692:static void* borrow_deref(BorrowRef* ref) {
    #####: 1693:    if (!ref || !ref->target) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1694:        fprintf(stderr, "borrow: null reference\n");
call    0 never executed
    #####: 1695:        return NULL;
        -: 1696:    }
    #####: 1697:    pthread_rwlock_rdlock(&ref->target->rwlock);
call    0 never executed
    #####: 1698:    if (ref->remembered_gen != ref->target->generation) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1699:        pthread_rwlock_unlock(&ref->target->rwlock);
call    0 never executed
    #####: 1700:        fprintf(stderr, "borrow: use-after-free detected [created at: %s]\n",
call    0 never executed
    #####: 1701:                ref->source_desc ? ref->source_desc : "unknown");
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1702:        return NULL;
        -: 1703:    }
    #####: 1704:    void* data = ref->target->data;
    #####: 1705:    pthread_rwlock_unlock(&ref->target->rwlock);
call    0 never executed
    #####: 1706:    return data;
        -: 1707:}
        -: 1708:
        -: 1709:/* IPGE-based borrowed reference creation */
function borrow_create called 1122 returned 100% blocks executed 86%
     1122: 1710:BorrowRef* borrow_create(Obj* obj, const char* source_desc) {
     1122: 1711:    if (!obj || IS_IMMEDIATE(obj)) return NULL;
branch  0 taken 1121 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 1120
        -: 1712:
        -: 1713:    /* Create a BorrowRef that stores the IPGE generation snapshot */
     1120: 1714:    BorrowRef* ref = calloc(1, sizeof(BorrowRef));
    1120*: 1715:    if (!ref) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 1120
        -: 1716:
        -: 1717:    /* IPGE mode: store actual Obj* and snapshot its generation */
     1120: 1718:    ref->ipge_target = obj;
     1120: 1719:    ref->remembered_gen = obj->generation;
     1120: 1720:    ref->source_desc = source_desc;
     1120: 1721:    ref->target = NULL;  /* Not using legacy GenObj mode */
     1120: 1722:    return ref;
        -: 1723:}
        -: 1724:
function borrow_get called 0 returned 0% blocks executed 0%
    #####: 1725:Obj* borrow_get(BorrowRef* ref) {
    #####: 1726:    if (!ref) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1727:    if (!borrow_is_valid(ref)) return NULL;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1728:    if (ref->ipge_target) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1729:        inc_ref(ref->ipge_target);
call    0 never executed
    #####: 1730:        return ref->ipge_target;
        -: 1731:    }
    #####: 1732:    return NULL;
        -: 1733:}
        -: 1734:
function borrow_invalidate_obj called 10054 returned 100% blocks executed 100%
    10054: 1735:void borrow_invalidate_obj(Obj* obj) {
    10054: 1736:    if (!obj || IS_IMMEDIATE(obj)) return;
branch  0 taken 10053 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 10052
        -: 1737:    /* IPGE: Evolve generation to invalidate all borrowed refs */
    10052: 1738:    obj->generation = ipge_evolve(obj->generation);
call    0 returned 10052
        -: 1739:}
        -: 1740:
        -: 1741:/* Closure support for safe lambda captures */
function genclosure_new called 0 returned 0% blocks executed 0%
    #####: 1742:static GenClosure* genclosure_new(BorrowRef** captures, int count, void* (*func)(void*), void* ctx) {
    #####: 1743:    GenClosure* c = calloc(1, sizeof(GenClosure));
    #####: 1744:    if (!c) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1745:    c->captures = captures;
    #####: 1746:    c->capture_count = count;
    #####: 1747:    c->func = func;
    #####: 1748:    c->ctx = ctx;
    #####: 1749:    return c;
        -: 1750:}
        -: 1751:
function genclosure_validate called 0 returned 0% blocks executed 0%
    #####: 1752:int genclosure_validate(GenClosure* c) {
    #####: 1753:    if (!c) return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1754:    for (int i = 0; i < c->capture_count; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 1755:        if (!borrow_is_valid(c->captures[i])) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1756:            return 0;
        -: 1757:        }
        -: 1758:    }
    #####: 1759:    return 1;
        -: 1760:}
        -: 1761:
function genclosure_call called 0 returned 0% blocks executed 0%
    #####: 1762:static void* genclosure_call(GenClosure* c) {
    #####: 1763:    if (!genclosure_validate(c)) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 1764:        fprintf(stderr, "genclosure: invalid capture detected\n");
call    0 never executed
    #####: 1765:        return NULL;
        -: 1766:    }
    #####: 1767:    return c->func ? c->func(c->ctx) : NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
        -: 1768:}
        -: 1769:
        -: 1770:
        -: 1771:/* ========== Closure Runtime ========== */
        -: 1772:typedef Obj* (*ClosureFn)(Obj** captures, Obj** args, int arg_count);
        -: 1773:
        -: 1774:struct Closure {
        -: 1775:    ClosureFn fn;
        -: 1776:    Obj** captures;
        -: 1777:    BorrowRef** capture_refs;
        -: 1778:    int capture_count;
        -: 1779:    int arity;
        -: 1780:};
        -: 1781:
function mk_closure called 1048 returned 100% blocks executed 87%
     1048: 1782:Obj* mk_closure(ClosureFn fn, Obj** captures, BorrowRef** refs, int count, int arity) {
     1048: 1783:    Obj* x = malloc(sizeof(Obj));
    1048*: 1784:    if (!x) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 1048
     1048: 1785:    x->mark = 1;
     1048: 1786:    x->scc_id = -1;
     1048: 1787:    x->is_pair = 0;
     1048: 1788:    x->scan_tag = 0;
     1048: 1789:    x->tag = TAG_CLOSURE;
     1048: 1790:    x->generation = _next_generation();
call    0 returned 1048
        -: 1791:
     1048: 1792:    Closure* c = calloc(1, sizeof(Closure));
     1048: 1793:    if (!c) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1048
    #####: 1794:        free(x);
    #####: 1795:        return NULL;
        -: 1796:    }
     1048: 1797:    c->fn = fn;
     1048: 1798:    c->capture_count = count;
     1048: 1799:    c->arity = arity;
        -: 1800:
        -: 1801:    /* Copy captures array - the passed array may be stack-allocated */
     1048: 1802:    if (count > 0 && captures) {
branch  0 taken 1012 (fallthrough)
branch  1 taken 36
branch  2 taken 1012 (fallthrough)
branch  3 taken 0
     1012: 1803:        c->captures = malloc(count * sizeof(Obj*));
     1012: 1804:        if (!c->captures) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1012
    #####: 1805:            free(c);
    #####: 1806:            free(x);
    #####: 1807:            return NULL;
        -: 1808:        }
     1012: 1809:        memcpy(c->captures, captures, count * sizeof(Obj*));
        -: 1810:
     1012: 1811:        if (refs) {
branch  0 taken 2 (fallthrough)
branch  1 taken 1010
        2: 1812:            c->capture_refs = malloc(count * sizeof(BorrowRef*));
        2: 1813:            if (c->capture_refs) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 1814:                memcpy(c->capture_refs, refs, count * sizeof(BorrowRef*));
        -: 1815:            }
        -: 1816:        } else {
     1010: 1817:            c->capture_refs = NULL;
        -: 1818:        }
        -: 1819:    } else {
       36: 1820:        c->captures = NULL;
       36: 1821:        c->capture_refs = NULL;
        -: 1822:    }
        -: 1823:
     2113: 1824:    for (int i = 0; i < count; i++) {
branch  0 taken 1065
branch  1 taken 1048 (fallthrough)
     1065: 1825:        if (c->captures && c->captures[i]) inc_ref(c->captures[i]);
branch  0 taken 1065 (fallthrough)
branch  1 taken 0
branch  2 taken 1065 (fallthrough)
branch  3 taken 0
call    4 returned 1065
        -: 1826:    }
        -: 1827:
     1048: 1828:    x->ptr = c;
     1048: 1829:    return x;
        -: 1830:}
        -: 1831:
function closure_release called 1048 returned 100% blocks executed 92%
     1048: 1832:void closure_release(Closure* c) {
    1048*: 1833:    if (!c) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 1048
     2113: 1834:    for (int i = 0; i < c->capture_count; i++) {
branch  0 taken 1065
branch  1 taken 1048 (fallthrough)
     1065: 1835:        if (c->captures && c->captures[i]) {
branch  0 taken 1065 (fallthrough)
branch  1 taken 0
branch  2 taken 1065 (fallthrough)
branch  3 taken 0
     1065: 1836:            dec_ref(c->captures[i]);
call    0 returned 1065
        -: 1837:        }
     1065: 1838:        if (c->capture_refs && c->capture_refs[i]) {
branch  0 taken 2 (fallthrough)
branch  1 taken 1063
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 1839:            borrow_release(c->capture_refs[i]);
call    0 returned 2
        -: 1840:        }
        -: 1841:    }
     1048: 1842:    free(c->captures);
     1048: 1843:    free(c->capture_refs);
     1048: 1844:    free(c);
        -: 1845:}
        -: 1846:
function closure_validate called 2210 returned 100% blocks executed 100%
     2210: 1847:int closure_validate(Closure* c) {
     2210: 1848:    if (!c || !c->capture_refs) return 1;
branch  0 taken 2210 (fallthrough)
branch  1 taken 0
branch  2 taken 2207 (fallthrough)
branch  3 taken 3
        5: 1849:    for (int i = 0; i < c->capture_count; i++) {
branch  0 taken 3
branch  1 taken 2 (fallthrough)
        3: 1850:        if (c->capture_refs[i] && !borrow_is_valid(c->capture_refs[i])) {
branch  0 taken 3 (fallthrough)
branch  1 taken 0
call    2 returned 3
branch  3 taken 1 (fallthrough)
branch  4 taken 2
        1: 1851:            return 0;
        -: 1852:        }
        -: 1853:    }
        2: 1854:    return 1;
        -: 1855:}
        -: 1856:
function call_closure called 2211 returned 100% blocks executed 79%
     2211: 1857:Obj* call_closure(Obj* clos, Obj** args, int arg_count) {
     2211: 1858:    if (!clos || clos->tag != TAG_CLOSURE) {
branch  0 taken 2210 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 2209
        2: 1859:        fprintf(stderr, "call_closure: not a closure\n");
call    0 returned 2
        2: 1860:        return NULL;
        -: 1861:    }
     2209: 1862:    Closure* c = (Closure*)clos->ptr;
    2209*: 1863:    if (!c) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 2209
     2209: 1864:    if (c->arity >= 0 && arg_count != c->arity) {
branch  0 taken 2206 (fallthrough)
branch  1 taken 3
branch  2 taken 1 (fallthrough)
branch  3 taken 2205
        1: 1865:        fprintf(stderr, "call_closure: arity mismatch (expected %d, got %d)\n", c->arity, arg_count);
call    0 returned 1
        1: 1866:        return NULL;
        -: 1867:    }
     2208: 1868:    if (!closure_validate(c)) {
call    0 returned 2208
branch  1 taken 0 (fallthrough)
branch  2 taken 2208
    #####: 1869:        fprintf(stderr, "call_closure: invalid capture detected\n");
call    0 never executed
    #####: 1870:        return NULL;
        -: 1871:    }
    2208*: 1872:    return c->fn ? c->fn(c->captures, args, arg_count) : NULL;
branch  0 taken 2208 (fallthrough)
branch  1 taken 0
call    2 returned 2208
        -: 1873:}
        -: 1874:
        -: 1875:
        -: 1876:/* ========== Constraint References (v0.5.0) ========== */
        -: 1877:/* Assertion-based safety for complex patterns */
        -: 1878:/* Thread-safe via pthread mutex (C99 + POSIX) */
        -: 1879:
        -: 1880:/* Enable debug mode with -DCONSTRAINT_DEBUG */
        -: 1881:#ifndef CONSTRAINT_DEBUG
        -: 1882:#define CONSTRAINT_DEBUG 0
        -: 1883:#endif
        -: 1884:
        -: 1885:#define MAX_CONSTRAINT_SOURCES 16
        -: 1886:
        -: 1887:typedef struct ConstraintObj {
        -: 1888:    void* data;
        -: 1889:    void (*destructor)(void*);
        -: 1890:    const char* owner;
        -: 1891:    int constraint_count;
        -: 1892:    int freed;
        -: 1893:    pthread_mutex_t mutex;
        -: 1894:#if CONSTRAINT_DEBUG
        -: 1895:    const char* sources[MAX_CONSTRAINT_SOURCES];
        -: 1896:    int source_count;
        -: 1897:#endif
        -: 1898:} ConstraintObj;
        -: 1899:
        -: 1900:typedef struct ConstraintRef {
        -: 1901:    ConstraintObj* target;
        -: 1902:    const char* source;
        -: 1903:    int released;
        -: 1904:    pthread_mutex_t mutex;
        -: 1905:} ConstraintRef;
        -: 1906:
function constraint_alloc called 0 returned 0% blocks executed 0%
    #####: 1907:static ConstraintObj* constraint_alloc(void* data, void (*destructor)(void*), const char* owner) {
    #####: 1908:    ConstraintObj* obj = calloc(1, sizeof(ConstraintObj));
    #####: 1909:    if (!obj) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1910:    obj->data = data;
    #####: 1911:    obj->destructor = destructor;
    #####: 1912:    obj->owner = owner;
    #####: 1913:    obj->constraint_count = 0;
    #####: 1914:    obj->freed = 0;
    #####: 1915:    pthread_mutex_init(&obj->mutex, NULL);
call    0 never executed
        -: 1916:#if CONSTRAINT_DEBUG
        -: 1917:    obj->source_count = 0;
        -: 1918:#endif
    #####: 1919:    return obj;
        -: 1920:}
        -: 1921:
function constraint_add called 0 returned 0% blocks executed 0%
    #####: 1922:static ConstraintRef* constraint_add(ConstraintObj* obj, const char* source) {
    #####: 1923:    if (!obj) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1924:    pthread_mutex_lock(&obj->mutex);
call    0 never executed
    #####: 1925:    if (obj->freed) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1926:        pthread_mutex_unlock(&obj->mutex);
call    0 never executed
    #####: 1927:        return NULL;
        -: 1928:    }
    #####: 1929:    ConstraintRef* ref = calloc(1, sizeof(ConstraintRef));
    #####: 1930:    if (!ref) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1931:        pthread_mutex_unlock(&obj->mutex);
call    0 never executed
    #####: 1932:        return NULL;
        -: 1933:    }
    #####: 1934:    ref->target = obj;
    #####: 1935:    ref->source = source;
    #####: 1936:    ref->released = 0;
    #####: 1937:    pthread_mutex_init(&ref->mutex, NULL);
call    0 never executed
    #####: 1938:    obj->constraint_count++;
        -: 1939:#if CONSTRAINT_DEBUG
        -: 1940:    if (obj->source_count < MAX_CONSTRAINT_SOURCES) {
        -: 1941:        obj->sources[obj->source_count++] = source;
        -: 1942:    }
        -: 1943:#endif
    #####: 1944:    pthread_mutex_unlock(&obj->mutex);
call    0 never executed
    #####: 1945:    return ref;
        -: 1946:}
        -: 1947:
        -: 1948:/* O(1) release with mutex protection */
function constraint_release called 0 returned 0% blocks executed 0%
    #####: 1949:int constraint_release(ConstraintRef* ref) {
    #####: 1950:    if (!ref || !ref->target) return -1;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1951:    pthread_mutex_lock(&ref->mutex);
call    0 never executed
    #####: 1952:    if (ref->released) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1953:        pthread_mutex_unlock(&ref->mutex);
call    0 never executed
    #####: 1954:        return -1;  /* Already released */
        -: 1955:    }
    #####: 1956:    ref->released = 1;
    #####: 1957:    pthread_mutex_unlock(&ref->mutex);
call    0 never executed
        -: 1958:
    #####: 1959:    pthread_mutex_lock(&ref->target->mutex);
call    0 never executed
    #####: 1960:    ref->target->constraint_count--;
    #####: 1961:    pthread_mutex_unlock(&ref->target->mutex);
call    0 never executed
    #####: 1962:    return 0;
        -: 1963:}
        -: 1964:
function constraint_free called 0 returned 0% blocks executed 0%
    #####: 1965:int constraint_free(ConstraintObj* obj) {
    #####: 1966:    if (!obj) return -1;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1967:    pthread_mutex_lock(&obj->mutex);
call    0 never executed
    #####: 1968:    if (obj->freed) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1969:        pthread_mutex_unlock(&obj->mutex);
call    0 never executed
    #####: 1970:        fprintf(stderr, "constraint: double free [owner: %s]\n", obj->owner ? obj->owner : "unknown");
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 1971:        return -1;
        -: 1972:    }
    #####: 1973:    if (obj->constraint_count > 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 1974:        pthread_mutex_unlock(&obj->mutex);
call    0 never executed
    #####: 1975:        fprintf(stderr, "constraint violation: cannot free [owner: %s] with %d active constraints\n",
call    0 never executed
    #####: 1976:                obj->owner ? obj->owner : "unknown", obj->constraint_count);
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1977:#ifdef CONSTRAINT_ASSERT
        -: 1978:        abort();
        -: 1979:#endif
    #####: 1980:        return -1;
        -: 1981:    }
    #####: 1982:    obj->freed = 1;
    #####: 1983:    if (obj->destructor && obj->data) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1984:        obj->destructor(obj->data);
call    0 never executed
        -: 1985:    }
    #####: 1986:    obj->data = NULL;
    #####: 1987:    pthread_mutex_unlock(&obj->mutex);
call    0 never executed
    #####: 1988:    pthread_mutex_destroy(&obj->mutex);
call    0 never executed
    #####: 1989:    return 0;
        -: 1990:}
        -: 1991:
function constraint_is_valid called 0 returned 0% blocks executed 0%
    #####: 1992:int constraint_is_valid(ConstraintRef* ref) {
    #####: 1993:    if (!ref || !ref->target) return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 1994:    pthread_mutex_lock(&ref->mutex);
call    0 never executed
    #####: 1995:    int rel = ref->released;
    #####: 1996:    pthread_mutex_unlock(&ref->mutex);
call    0 never executed
    #####: 1997:    if (rel) return 0;
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 1998:
    #####: 1999:    pthread_mutex_lock(&ref->target->mutex);
call    0 never executed
    #####: 2000:    int freed = ref->target->freed;
    #####: 2001:    pthread_mutex_unlock(&ref->target->mutex);
call    0 never executed
    #####: 2002:    return !freed;
        -: 2003:}
        -: 2004:
function constraint_deref called 0 returned 0% blocks executed 0%
    #####: 2005:static void* constraint_deref(ConstraintRef* ref) {
    #####: 2006:    if (!constraint_is_valid(ref)) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2007:        fprintf(stderr, "constraint: invalid dereference\n");
call    0 never executed
    #####: 2008:        return NULL;
        -: 2009:    }
    #####: 2010:    return ref->target->data;
        -: 2011:}
        -: 2012:
        -: 2013:/* Arithmetic Operations - with unboxed integer support */
        -: 2014:
        -: 2015:/* Check if boxed value is a float (immediates are never float) */
function num_is_float called 43 returned 100% blocks executed 100%
       43: 2016:int num_is_float(Obj* x) {
       43: 2017:    if (!x || IS_IMMEDIATE(x)) return 0;
branch  0 taken 43 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 42
       42: 2018:    return x->tag == TAG_FLOAT;
        -: 2019:}
        -: 2020:
        -: 2021:/* Convert to double - handles both boxed and immediate */
function num_to_double called 16 returned 100% blocks executed 75%
       16: 2022:double num_to_double(Obj* x) {
      16*: 2023:    if (!x) return 0.0;
branch  0 taken 0 (fallthrough)
branch  1 taken 16
      16*: 2024:    if (IS_IMMEDIATE(x)) return (double)IMMEDIATE_VALUE(x);
branch  0 taken 0 (fallthrough)
branch  1 taken 16
       16: 2025:    if (x->tag == TAG_FLOAT) return x->f;
branch  0 taken 15 (fallthrough)
branch  1 taken 1
        1: 2026:    return (double)x->i;
        -: 2027:}
        -: 2028:
        -: 2029:/* Fast path: both args are immediate integers -> immediate result */
function add called 1007 returned 100% blocks executed 83%
     1007: 2030:Obj* add(Obj* a, Obj* b) {
        -: 2031:    /* Fast path: both immediate integers */
     1007: 2032:    if (IS_IMMEDIATE(a) && IS_IMMEDIATE(b)) {
branch  0 taken 1003 (fallthrough)
branch  1 taken 4
branch  2 taken 1002 (fallthrough)
branch  3 taken 1
     1002: 2033:        return mk_int_unboxed(IMMEDIATE_VALUE(a) + IMMEDIATE_VALUE(b));
call    0 returned 1002
        -: 2034:    }
        -: 2035:    /* Handle NULL */
       5*: 2036:    if (!a && !b) return mk_int_unboxed(0);
branch  0 taken 0 (fallthrough)
branch  1 taken 5
branch  2 never executed (fallthrough)
branch  3 never executed
call    4 never executed
       5*: 2037:    if (!a) return b;
branch  0 taken 0 (fallthrough)
branch  1 taken 5
        5: 2038:    if (!b) return a;
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        -: 2039:    /* Float path */
        4: 2040:    if (num_is_float(a) || num_is_float(b)) {
call    0 returned 4
branch  1 taken 3 (fallthrough)
branch  2 taken 1
call    3 returned 3
branch  4 taken 1 (fallthrough)
branch  5 taken 2
        2: 2041:        return mk_float(num_to_double(a) + num_to_double(b));
call    0 returned 2
call    1 returned 2
call    2 returned 2
        -: 2042:    }
        -: 2043:    /* Mixed: one immediate, one boxed int */
        2: 2044:    return mk_int_unboxed(obj_to_int(a) + obj_to_int(b));
call    0 returned 2
call    1 returned 2
call    2 returned 2
        -: 2045:}
        -: 2046:
function sub called 6 returned 100% blocks executed 77%
        6: 2047:Obj* sub(Obj* a, Obj* b) {
        6: 2048:    if (IS_IMMEDIATE(a) && IS_IMMEDIATE(b)) {
branch  0 taken 2 (fallthrough)
branch  1 taken 4
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 2049:        return mk_int_unboxed(IMMEDIATE_VALUE(a) - IMMEDIATE_VALUE(b));
call    0 returned 2
        -: 2050:    }
       4*: 2051:    if (!a && !b) return mk_int_unboxed(0);
branch  0 taken 1 (fallthrough)
branch  1 taken 3
branch  2 taken 0 (fallthrough)
branch  3 taken 1
call    4 never executed
        4: 2052:    if (!a) return mk_int_unboxed(-obj_to_int(b));
branch  0 taken 1 (fallthrough)
branch  1 taken 3
call    2 returned 1
call    3 returned 1
        3: 2053:    if (!b) return a;
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        2: 2054:    if (num_is_float(a) || num_is_float(b)) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
call    3 returned 2
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    #####: 2055:        return mk_float(num_to_double(a) - num_to_double(b));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2056:    }
        2: 2057:    return mk_int_unboxed(obj_to_int(a) - obj_to_int(b));
call    0 returned 2
call    1 returned 2
call    2 returned 2
        -: 2058:}
        -: 2059:
function mul called 4 returned 100% blocks executed 70%
        4: 2060:Obj* mul(Obj* a, Obj* b) {
        4: 2061:    if (IS_IMMEDIATE(a) && IS_IMMEDIATE(b)) {
branch  0 taken 2 (fallthrough)
branch  1 taken 2
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 2062:        return mk_int_unboxed(IMMEDIATE_VALUE(a) * IMMEDIATE_VALUE(b));
call    0 returned 2
        -: 2063:    }
       2*: 2064:    if (!a || !b) return mk_int_unboxed(0);
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
call    4 never executed
        2: 2065:    if (num_is_float(a) || num_is_float(b)) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
call    3 returned 2
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    #####: 2066:        return mk_float(num_to_double(a) * num_to_double(b));
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2067:    }
        2: 2068:    return mk_int_unboxed(obj_to_int(a) * obj_to_int(b));
call    0 returned 2
call    1 returned 2
call    2 returned 2
        -: 2069:}
        -: 2070:
function div_op called 5 returned 100% blocks executed 79%
        5: 2071:Obj* div_op(Obj* a, Obj* b) {
        5: 2072:    if (IS_IMMEDIATE(a) && IS_IMMEDIATE(b)) {
branch  0 taken 2 (fallthrough)
branch  1 taken 3
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 2073:        long bv = IMMEDIATE_VALUE(b);
       2*: 2074:        if (bv == 0) return mk_int_unboxed(0);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
call    2 never executed
        2: 2075:        return mk_int_unboxed(IMMEDIATE_VALUE(a) / bv);
call    0 returned 2
        -: 2076:    }
       3*: 2077:    if (!a || !b) return mk_int_unboxed(0);
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 3
call    4 never executed
        3: 2078:    if (num_is_float(a) || num_is_float(b)) {
call    0 returned 3
branch  1 taken 2 (fallthrough)
branch  2 taken 1
call    3 returned 2
branch  4 taken 0 (fallthrough)
branch  5 taken 2
        1: 2079:        double denom = num_to_double(b);
call    0 returned 1
       1*: 2080:        if (denom == 0.0) return mk_float(0.0);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
        1: 2081:        return mk_float(num_to_double(a) / denom);
call    0 returned 1
call    1 returned 1
        -: 2082:    }
        2: 2083:    long bv = obj_to_int(b);
call    0 returned 2
        2: 2084:    if (bv == 0) return mk_int_unboxed(0);
branch  0 taken 1 (fallthrough)
branch  1 taken 1
call    2 returned 1
        1: 2085:    return mk_int_unboxed(obj_to_int(a) / bv);
call    0 returned 1
call    1 returned 1
        -: 2086:}
        -: 2087:
function mod_op called 4 returned 100% blocks executed 75%
        4: 2088:Obj* mod_op(Obj* a, Obj* b) {
        4: 2089:    if (IS_IMMEDIATE(a) && IS_IMMEDIATE(b)) {
branch  0 taken 2 (fallthrough)
branch  1 taken 2
branch  2 taken 2 (fallthrough)
branch  3 taken 0
        2: 2090:        long bv = IMMEDIATE_VALUE(b);
       2*: 2091:        if (bv == 0) return mk_int_unboxed(0);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
call    2 never executed
        2: 2092:        return mk_int_unboxed(IMMEDIATE_VALUE(a) % bv);
call    0 returned 2
        -: 2093:    }
        2: 2094:    long bv = obj_to_int(b);
call    0 returned 2
       2*: 2095:    if (!a || !b || bv == 0) return mk_int_unboxed(0);
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 2 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 2
call    6 never executed
        2: 2096:    return mk_int_unboxed(obj_to_int(a) % bv);
call    0 returned 2
call    1 returned 2
        -: 2097:}
        -: 2098:
        -: 2099:/* Comparison Operations - with unboxed integer support */
function eq_op called 4 returned 100% blocks executed 79%
        4: 2100:Obj* eq_op(Obj* a, Obj* b) {
        -: 2101:    /* Fast path: both immediate */
        4: 2102:    if (IS_IMMEDIATE(a) && IS_IMMEDIATE(b)) {
branch  0 taken 1 (fallthrough)
branch  1 taken 3
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 2103:        return mk_int_unboxed(a == b ? 1 : 0);
call    0 returned 1
        -: 2104:    }
       3*: 2105:    if (!a && !b) return mk_int_unboxed(1);
branch  0 taken 0 (fallthrough)
branch  1 taken 3
branch  2 never executed (fallthrough)
branch  3 never executed
call    4 never executed
       3*: 2106:    if (!a || !b) return mk_int_unboxed(0);
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 3
call    4 never executed
        3: 2107:    if (num_is_float(a) || num_is_float(b)) {
call    0 returned 3
branch  1 taken 2 (fallthrough)
branch  2 taken 1
call    3 returned 2
branch  4 taken 0 (fallthrough)
branch  5 taken 2
        1: 2108:        return mk_int_unboxed(num_to_double(a) == num_to_double(b) ? 1 : 0);
call    0 returned 1
call    1 returned 1
call    2 returned 1
        -: 2109:    }
        2: 2110:    return mk_int_unboxed(obj_to_int(a) == obj_to_int(b) ? 1 : 0);
call    0 returned 2
call    1 returned 2
call    2 returned 2
        -: 2111:}
        -: 2112:
function lt_op called 4 returned 100% blocks executed 70%
        4: 2113:Obj* lt_op(Obj* a, Obj* b) {
        4: 2114:    if (IS_IMMEDIATE(a) && IS_IMMEDIATE(b)) {
branch  0 taken 1 (fallthrough)
branch  1 taken 3
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 2115:        return mk_int_unboxed(IMMEDIATE_VALUE(a) < IMMEDIATE_VALUE(b) ? 1 : 0);
call    0 returned 1
        -: 2116:    }
       3*: 2117:    if (!a || !b) return mk_int_unboxed(0);
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 3
call    4 never executed
        3: 2118:    if (num_is_float(a) || num_is_float(b)) {
call    0 returned 3
branch  1 taken 3 (fallthrough)
branch  2 taken 0
call    3 returned 3
branch  4 taken 0 (fallthrough)
branch  5 taken 3
    #####: 2119:        return mk_int_unboxed(num_to_double(a) < num_to_double(b) ? 1 : 0);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2120:    }
        3: 2121:    return mk_int_unboxed(obj_to_int(a) < obj_to_int(b) ? 1 : 0);
call    0 returned 3
call    1 returned 3
call    2 returned 3
        -: 2122:}
        -: 2123:
function gt_op called 3 returned 100% blocks executed 70%
        3: 2124:Obj* gt_op(Obj* a, Obj* b) {
        3: 2125:    if (IS_IMMEDIATE(a) && IS_IMMEDIATE(b)) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 2126:        return mk_int_unboxed(IMMEDIATE_VALUE(a) > IMMEDIATE_VALUE(b) ? 1 : 0);
call    0 returned 1
        -: 2127:    }
       2*: 2128:    if (!a || !b) return mk_int_unboxed(0);
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
call    4 never executed
        2: 2129:    if (num_is_float(a) || num_is_float(b)) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
call    3 returned 2
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    #####: 2130:        return mk_int_unboxed(num_to_double(a) > num_to_double(b) ? 1 : 0);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2131:    }
        2: 2132:    return mk_int_unboxed(obj_to_int(a) > obj_to_int(b) ? 1 : 0);
call    0 returned 2
call    1 returned 2
call    2 returned 2
        -: 2133:}
        -: 2134:
function le_op called 3 returned 100% blocks executed 70%
        3: 2135:Obj* le_op(Obj* a, Obj* b) {
        3: 2136:    if (IS_IMMEDIATE(a) && IS_IMMEDIATE(b)) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 2137:        return mk_int_unboxed(IMMEDIATE_VALUE(a) <= IMMEDIATE_VALUE(b) ? 1 : 0);
call    0 returned 1
        -: 2138:    }
       2*: 2139:    if (!a || !b) return mk_int_unboxed(0);
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
call    4 never executed
        2: 2140:    if (num_is_float(a) || num_is_float(b)) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
call    3 returned 2
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    #####: 2141:        return mk_int_unboxed(num_to_double(a) <= num_to_double(b) ? 1 : 0);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2142:    }
        2: 2143:    return mk_int_unboxed(obj_to_int(a) <= obj_to_int(b) ? 1 : 0);
call    0 returned 2
call    1 returned 2
call    2 returned 2
        -: 2144:}
        -: 2145:
function ge_op called 3 returned 100% blocks executed 70%
        3: 2146:Obj* ge_op(Obj* a, Obj* b) {
        3: 2147:    if (IS_IMMEDIATE(a) && IS_IMMEDIATE(b)) {
branch  0 taken 1 (fallthrough)
branch  1 taken 2
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 2148:        return mk_int_unboxed(IMMEDIATE_VALUE(a) >= IMMEDIATE_VALUE(b) ? 1 : 0);
call    0 returned 1
        -: 2149:    }
       2*: 2150:    if (!a || !b) return mk_int_unboxed(0);
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
call    4 never executed
        2: 2151:    if (num_is_float(a) || num_is_float(b)) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
call    3 returned 2
branch  4 taken 0 (fallthrough)
branch  5 taken 2
    #####: 2152:        return mk_int_unboxed(num_to_double(a) >= num_to_double(b) ? 1 : 0);
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2153:    }
        2: 2154:    return mk_int_unboxed(obj_to_int(a) >= obj_to_int(b) ? 1 : 0);
call    0 returned 2
call    1 returned 2
call    2 returned 2
        -: 2155:}
        -: 2156:
function not_op called 2 returned 100% blocks executed 50%
        2: 2157:Obj* not_op(Obj* a) {
       2*: 2158:    if (!a) return mk_int_unboxed(1);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
call    2 never executed
        2: 2159:    if (IS_IMMEDIATE(a)) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 2160:        return mk_int_unboxed(IMMEDIATE_VALUE(a) == 0 ? 1 : 0);
call    0 never executed
        -: 2161:    }
        2: 2162:    return mk_int_unboxed(a->i == 0 ? 1 : 0);
call    0 returned 2
        -: 2163:}
        -: 2164:
function is_truthy called 4 returned 100% blocks executed 70%
        4: 2165:int is_truthy(Obj* x) {
        4: 2166:    if (!x) return 0;
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        -: 2167:    /* Fast path: immediate integer */
        3: 2168:    if (IS_IMMEDIATE(x)) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 2169:        return IMMEDIATE_VALUE(x) != 0;
        -: 2170:    }
        3: 2171:    switch (x->tag) {
branch  0 taken 2
branch  1 taken 0
branch  2 taken 0
branch  3 taken 1
        2: 2172:    case TAG_INT:
        2: 2173:        return x->i != 0;
    #####: 2174:    case TAG_FLOAT:
    #####: 2175:        return x->f != 0.0;
    #####: 2176:    case TAG_CHAR:
    #####: 2177:        return x->i != 0;
        1: 2178:    default:
        1: 2179:        return 1;
        -: 2180:    }
        -: 2181:}
        -: 2182:
        -: 2183:/* Primitive aliases for compiler */
function prim_add called 5 returned 100% blocks executed 100%
        5: 2184:Obj* prim_add(Obj* a, Obj* b) { return add(a, b); }
call    0 returned 5
function prim_sub called 5 returned 100% blocks executed 100%
        5: 2185:Obj* prim_sub(Obj* a, Obj* b) { return sub(a, b); }
call    0 returned 5
function prim_mul called 3 returned 100% blocks executed 100%
        3: 2186:Obj* prim_mul(Obj* a, Obj* b) { return mul(a, b); }
call    0 returned 3
function prim_div called 4 returned 100% blocks executed 100%
        4: 2187:Obj* prim_div(Obj* a, Obj* b) { return div_op(a, b); }
call    0 returned 4
function prim_mod called 3 returned 100% blocks executed 100%
        3: 2188:Obj* prim_mod(Obj* a, Obj* b) { return mod_op(a, b); }
call    0 returned 3
function prim_lt called 3 returned 100% blocks executed 100%
        3: 2189:Obj* prim_lt(Obj* a, Obj* b) { return lt_op(a, b); }
call    0 returned 3
function prim_gt called 2 returned 100% blocks executed 100%
        2: 2190:Obj* prim_gt(Obj* a, Obj* b) { return gt_op(a, b); }
call    0 returned 2
function prim_le called 2 returned 100% blocks executed 100%
        2: 2191:Obj* prim_le(Obj* a, Obj* b) { return le_op(a, b); }
call    0 returned 2
function prim_ge called 2 returned 100% blocks executed 100%
        2: 2192:Obj* prim_ge(Obj* a, Obj* b) { return ge_op(a, b); }
call    0 returned 2
function prim_eq called 3 returned 100% blocks executed 100%
        3: 2193:Obj* prim_eq(Obj* a, Obj* b) { return eq_op(a, b); }
call    0 returned 3
function prim_not called 2 returned 100% blocks executed 100%
        2: 2194:Obj* prim_not(Obj* a) { return not_op(a); }
call    0 returned 2
function prim_abs called 3 returned 100% blocks executed 36%
        3: 2195:Obj* prim_abs(Obj* a) {
       3*: 2196:    if (!a) return mk_int_unboxed(0);
branch  0 taken 0 (fallthrough)
branch  1 taken 3
call    2 never executed
        3: 2197:    if (IS_IMMEDIATE(a)) {
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 2198:        long v = IMMEDIATE_VALUE(a);
    #####: 2199:        return mk_int_unboxed(v < 0 ? -v : v);
call    0 never executed
        -: 2200:    }
       3*: 2201:    if (a->tag == TAG_FLOAT) return mk_float(a->f < 0 ? -a->f : a->f);
branch  0 taken 0 (fallthrough)
branch  1 taken 3
branch  2 never executed (fallthrough)
branch  3 never executed
call    4 never executed
        3: 2202:    return mk_int_unboxed(a->i < 0 ? -a->i : a->i);
call    0 returned 3
        -: 2203:}
        -: 2204:
        -: 2205:/* Type predicate wrappers - return Obj* for uniformity */
        -: 2206:/* Use obj_tag() to handle immediate values (tagged pointers) */
function prim_null called 2 returned 100% blocks executed 100%
        2: 2207:Obj* prim_null(Obj* x) { return mk_int(x == NULL ? 1 : 0); }
call    0 returned 2
function prim_pair called 2 returned 100% blocks executed 100%
        2: 2208:Obj* prim_pair(Obj* x) { return mk_int(x && obj_tag(x) == TAG_PAIR ? 1 : 0); }
branch  0 taken 2 (fallthrough)
branch  1 taken 0
call    2 returned 2
branch  3 taken 1 (fallthrough)
branch  4 taken 1
call    5 returned 2
function prim_int called 2 returned 100% blocks executed 100%
        2: 2209:Obj* prim_int(Obj* x) { return mk_int(obj_tag(x) == TAG_INT ? 1 : 0); }
call    0 returned 2
call    1 returned 2
function prim_float called 2 returned 100% blocks executed 100%
        2: 2210:Obj* prim_float(Obj* x) { return mk_int(x && obj_tag(x) == TAG_FLOAT ? 1 : 0); }
branch  0 taken 2 (fallthrough)
branch  1 taken 0
call    2 returned 2
branch  3 taken 1 (fallthrough)
branch  4 taken 1
call    5 returned 2
function prim_char called 2 returned 100% blocks executed 100%
        2: 2211:Obj* prim_char(Obj* x) { return mk_int(obj_tag(x) == TAG_CHAR ? 1 : 0); }
call    0 returned 2
call    1 returned 2
function prim_sym called 2 returned 100% blocks executed 100%
        2: 2212:Obj* prim_sym(Obj* x) { return mk_int(x && obj_tag(x) == TAG_SYM ? 1 : 0); }
branch  0 taken 2 (fallthrough)
branch  1 taken 0
call    2 returned 2
branch  3 taken 1 (fallthrough)
branch  4 taken 1
call    5 returned 2
        -: 2213:
        -: 2214:/* I/O Primitives */
        -: 2215:void print_obj(Obj* x);  /* forward declaration */
        -: 2216:
        -: 2217:/* Check if a list is a string (all chars) */
function is_string_list called 0 returned 0% blocks executed 0%
    #####: 2218:int is_string_list(Obj* xs) {
    #####: 2219:    while (xs && obj_tag(xs) == TAG_PAIR) {
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed (fallthrough)
    #####: 2220:        if (obj_tag(xs->a) != TAG_CHAR) return 0;
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2221:        xs = xs->b;
        -: 2222:    }
    #####: 2223:    return xs == NULL; /* Must be proper list */
        -: 2224:}
        -: 2225:
        -: 2226:/* Print a string list as a quoted string */
function print_string called 0 returned 0% blocks executed 0%
    #####: 2227:void print_string(Obj* xs) {
    #####: 2228:    while (xs && obj_tag(xs) == TAG_PAIR) {
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed (fallthrough)
    #####: 2229:        if (obj_tag(xs->a) == TAG_CHAR) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2230:            printf("%c", (char)obj_to_char_val(xs->a));
call    0 never executed
call    1 never executed
        -: 2231:        }
    #####: 2232:        xs = xs->b;
        -: 2233:    }
    #####: 2234:}
        -: 2235:
function print_list called 0 returned 0% blocks executed 0%
    #####: 2236:void print_list(Obj* xs) {
        -: 2237:    /* Check if this is a string (list of chars) */
    #####: 2238:    if (is_string_list(xs)) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 2239:        print_string(xs);
call    0 never executed
    #####: 2240:        return;
        -: 2241:    }
    #####: 2242:    printf("(");
call    0 never executed
    #####: 2243:    int first = 1;
    #####: 2244:    while (xs && xs->tag == TAG_PAIR) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 2245:        if (!first) printf(" ");
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 2246:        first = 0;
    #####: 2247:        print_obj(xs->a);
call    0 never executed
    #####: 2248:        xs = xs->b;
        -: 2249:    }
    #####: 2250:    if (xs) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2251:        printf(" . ");
call    0 never executed
    #####: 2252:        print_obj(xs);
call    0 never executed
        -: 2253:    }
    #####: 2254:    printf(")");
call    0 never executed
        -: 2255:}
        -: 2256:
function print_obj called 0 returned 0% blocks executed 0%
    #####: 2257:void print_obj(Obj* x) {
    #####: 2258:    if (!x) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2259:        printf("()");
call    0 never executed
    #####: 2260:        return;
        -: 2261:    }
    #####: 2262:    switch (x->tag) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
    #####: 2263:    case TAG_INT:
    #####: 2264:        printf("%ld", x->i);
call    0 never executed
    #####: 2265:        break;
    #####: 2266:    case TAG_FLOAT:
    #####: 2267:        printf("%g", x->f);
call    0 never executed
    #####: 2268:        break;
    #####: 2269:    case TAG_CHAR:
    #####: 2270:        printf("%c", (char)x->i);
call    0 never executed
    #####: 2271:        break;
    #####: 2272:    case TAG_SYM:
    #####: 2273:        printf("%s", x->ptr ? (char*)x->ptr : "nil");
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 2274:        break;
    #####: 2275:    case TAG_PAIR:
    #####: 2276:        print_list(x);
call    0 never executed
    #####: 2277:        break;
    #####: 2278:    case TAG_CLOSURE:
    #####: 2279:        printf("#<closure>");
call    0 never executed
    #####: 2280:        break;
    #####: 2281:    case TAG_BOX:
    #####: 2282:        printf("#<box>");
call    0 never executed
    #####: 2283:        break;
    #####: 2284:    case TAG_CHANNEL:
    #####: 2285:        printf("#<channel>");
call    0 never executed
    #####: 2286:        break;
    #####: 2287:    default:
    #####: 2288:        printf("#<object:%d>", x->tag);
call    0 never executed
    #####: 2289:        break;
        -: 2290:    }
        -: 2291:}
        -: 2292:
function prim_display called 0 returned 0% blocks executed 0%
    #####: 2293:Obj* prim_display(Obj* x) {
    #####: 2294:    print_obj(x);
call    0 never executed
    #####: 2295:    return NULL;
        -: 2296:}
        -: 2297:
function prim_print called 0 returned 0% blocks executed 0%
    #####: 2298:Obj* prim_print(Obj* x) {
    #####: 2299:    print_obj(x);
call    0 never executed
    #####: 2300:    printf("\n");
call    0 never executed
    #####: 2301:    return NULL;
        -: 2302:}
        -: 2303:
function prim_newline called 0 returned 0% blocks executed 0%
    #####: 2304:Obj* prim_newline(void) {
    #####: 2305:    printf("\n");
call    0 never executed
    #####: 2306:    return NULL;
        -: 2307:}
        -: 2308:
        -: 2309:/* Type introspection */
function ctr_tag called 3 returned 100% blocks executed 37%
        3: 2310:Obj* ctr_tag(Obj* x) {
        3: 2311:    if (!x) return mk_sym("nil");
branch  0 taken 1 (fallthrough)
branch  1 taken 2
call    2 returned 1
        2: 2312:    switch (x->tag) {
branch  0 taken 1
branch  1 taken 0
branch  2 taken 0
branch  3 taken 0
branch  4 taken 1
branch  5 taken 0
branch  6 taken 0
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
        1: 2313:    case TAG_INT: return mk_sym("int");
call    0 returned 1
    #####: 2314:    case TAG_FLOAT: return mk_sym("float");
call    0 never executed
    #####: 2315:    case TAG_CHAR: return mk_sym("char");
call    0 never executed
    #####: 2316:    case TAG_SYM: return mk_sym("sym");
call    0 never executed
        1: 2317:    case TAG_PAIR: return mk_sym("cell");
call    0 returned 1
    #####: 2318:    case TAG_BOX: return mk_sym("box");
call    0 never executed
    #####: 2319:    case TAG_CLOSURE: return mk_sym("closure");
call    0 never executed
    #####: 2320:    case TAG_CHANNEL: return mk_sym("channel");
call    0 never executed
    #####: 2321:    case TAG_ATOM: return mk_sym("atom");
call    0 never executed
    #####: 2322:    case TAG_THREAD: return mk_sym("thread");
call    0 never executed
    #####: 2323:    default:
    #####: 2324:        if (x->tag >= TAG_USER_BASE) return mk_sym("user");
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 2325:        return mk_sym("unknown");
call    0 never executed
        -: 2326:    }
        -: 2327:}
        -: 2328:
function ctr_arg called 2 returned 100% blocks executed 57%
        2: 2329:Obj* ctr_arg(Obj* x, Obj* idx) {
       2*: 2330:    if (!x || !idx) return NULL;
branch  0 taken 2 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2
        2: 2331:    long i = idx->i;
        2: 2332:    switch (x->tag) {
branch  0 taken 2
branch  1 taken 0
branch  2 taken 0
        2: 2333:    case TAG_PAIR:
        2: 2334:        if (i == 0) return x->a;
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 2335:        if (i == 1) return x->b;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
    #####: 2336:        return NULL;
    #####: 2337:    case TAG_BOX:
    #####: 2338:        if (i == 0) return (Obj*)x->ptr;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2339:        return NULL;
    #####: 2340:    default:
    #####: 2341:        return NULL;
        -: 2342:    }
        -: 2343:}
        -: 2344:
        -: 2345:/* Character primitives */
function char_to_int called 2 returned 100% blocks executed 100%
        2: 2346:Obj* char_to_int(Obj* c) {
        2: 2347:    if (obj_tag(c) != TAG_CHAR) return mk_int(0);
call    0 returned 2
branch  1 taken 1 (fallthrough)
branch  2 taken 1
call    3 returned 1
        1: 2348:    return mk_int(obj_to_char_val(c));
call    0 returned 1
call    1 returned 1
        -: 2349:}
        -: 2350:
function int_to_char called 2 returned 100% blocks executed 70%
        2: 2351:Obj* int_to_char(Obj* n) {
       2*: 2352:    if (!n) return mk_char(0);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
call    2 never executed
       2*: 2353:    return mk_char((char)(obj_tag(n) == TAG_INT ? obj_to_int(n) : (long)n->f));
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
call    3 returned 2
call    4 returned 2
        -: 2354:}
        -: 2355:
        -: 2356:/* Float primitives */
function int_to_float called 1 returned 100% blocks executed 70%
        1: 2357:Obj* int_to_float(Obj* n) {
       1*: 2358:    if (!n) return mk_float(0.0);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*: 2359:    return mk_float((double)(obj_tag(n) == TAG_INT ? obj_to_int(n) : n->f));
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
call    3 returned 1
call    4 returned 1
        -: 2360:}
        -: 2361:
function float_to_int called 1 returned 100% blocks executed 60%
        1: 2362:Obj* float_to_int(Obj* f) {
       1*: 2363:    if (!f) return mk_int(0);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
call    2 never executed
       1*: 2364:    return mk_int((long)(obj_tag(f) == TAG_FLOAT ? f->f : obj_to_int(f)));
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0
call    3 never executed
call    4 returned 1
        -: 2365:}
        -: 2366:
function prim_floor called 2 returned 100% blocks executed 69%
        2: 2367:Obj* prim_floor(Obj* f) {
       2*: 2368:    if (!f) return mk_int(0);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
call    2 never executed
        2: 2369:    if (obj_tag(f) == TAG_FLOAT) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2: 2370:        double v = f->f;
       2*: 2371:        return mk_float(v >= 0 ? (long)v : (long)v - (v != (long)v ? 1 : 0));
branch  0 taken 1 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
call    4 returned 2
        -: 2372:    }
    #####: 2373:    return mk_int(obj_to_int(f));
call    0 never executed
call    1 never executed
        -: 2374:}
        -: 2375:
function prim_ceil called 2 returned 100% blocks executed 69%
        2: 2376:Obj* prim_ceil(Obj* f) {
       2*: 2377:    if (!f) return mk_int(0);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
call    2 never executed
        2: 2378:    if (obj_tag(f) == TAG_FLOAT) {
call    0 returned 2
branch  1 taken 2 (fallthrough)
branch  2 taken 0
        2: 2379:        double v = f->f;
       2*: 2380:        return mk_float(v >= 0 ? (long)v + (v != (long)v ? 1 : 0) : (long)v);
branch  0 taken 1 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0
call    4 returned 2
        -: 2381:    }
    #####: 2382:    return mk_int(obj_to_int(f));
call    0 never executed
call    1 never executed
        -: 2383:}
        -: 2384:
        -: 2385:/* Higher-order function primitives */
function prim_apply called 0 returned 0% blocks executed 0%
    #####: 2386:Obj* prim_apply(Obj* fn, Obj* args) {
    #####: 2387:    if (!fn) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2388:    /* Count args */
    #####: 2389:    int n = 0;
    #####: 2390:    Obj* p = args;
    #####: 2391:    while (p && p->tag == TAG_PAIR) { n++; p = p->b; }
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed
branch  3 never executed (fallthrough)
        -: 2392:
        -: 2393:    /* Build args array */
    #####: 2394:    Obj** arr = n > 0 ? malloc(n * sizeof(Obj*)) : NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2395:    p = args;
    #####: 2396:    for (int i = 0; i < n; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2397:        arr[i] = p->a;
    #####: 2398:        p = p->b;
        -: 2399:    }
        -: 2400:
    #####: 2401:    Obj* result = call_closure(fn, arr, n);
call    0 never executed
    #####: 2402:    if (arr) free(arr);
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2403:    return result;
        -: 2404:}
        -: 2405:
        -: 2406:/* Compose: (compose f g) returns a function that applies g then f */
        -: 2407:Obj* compose_wrapper(Obj** captures, Obj** args, int n);
        -: 2408:
function prim_compose called 0 returned 0% blocks executed 0%
    #####: 2409:Obj* prim_compose(Obj* f, Obj* g) {
    #####: 2410:    if (!f || !g) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2411:    Obj** caps = malloc(2 * sizeof(Obj*));
    #####: 2412:    caps[0] = f; inc_ref(f);
call    0 never executed
    #####: 2413:    caps[1] = g; inc_ref(g);
call    0 never executed
    #####: 2414:    return mk_closure(compose_wrapper, caps, NULL, 2, 1);
call    0 never executed
        -: 2415:}
        -: 2416:
function compose_wrapper called 0 returned 0% blocks executed 0%
    #####: 2417:Obj* compose_wrapper(Obj** captures, Obj** args, int n) {
    #####: 2418:    if (n < 1 || !captures) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2419:    Obj* f = captures[0];
    #####: 2420:    Obj* g = captures[1];
        -: 2421:    /* Apply g first */
    #####: 2422:    Obj* intermediate = call_closure(g, args, n);
call    0 never executed
        -: 2423:    /* Then apply f */
    #####: 2424:    Obj* final_args[1] = { intermediate };
    #####: 2425:    Obj* result = call_closure(f, final_args, 1);
call    0 never executed
    #####: 2426:    dec_ref(intermediate);
call    0 never executed
    #####: 2427:    return result;
        -: 2428:}
        -: 2429:
        -: 2430:/* List Operations */
function car called 24 returned 100% blocks executed 100%
       24: 2431:Obj* car(Obj* p) {
       24: 2432:    if (!p || p->tag != TAG_PAIR) return NULL;
branch  0 taken 22 (fallthrough)
branch  1 taken 2
branch  2 taken 2 (fallthrough)
branch  3 taken 20
       20: 2433:    return p->a;
        -: 2434:}
        -: 2435:
function cdr called 12 returned 100% blocks executed 100%
       12: 2436:Obj* cdr(Obj* p) {
       12: 2437:    if (!p || p->tag != TAG_PAIR) return NULL;
branch  0 taken 10 (fallthrough)
branch  1 taken 2
branch  2 taken 2 (fallthrough)
branch  3 taken 8
        8: 2438:    return p->b;
        -: 2439:}
        -: 2440:
        -: 2441:/* Aliases for compiler - return owned references */
function obj_car called 24 returned 100% blocks executed 100%
       24: 2442:Obj* obj_car(Obj* p) {
       24: 2443:    Obj* r = car(p);
call    0 returned 24
       24: 2444:    if (r) inc_ref(r);
branch  0 taken 19 (fallthrough)
branch  1 taken 5
call    2 returned 19
       24: 2445:    return r;
        -: 2446:}
function obj_cdr called 12 returned 100% blocks executed 100%
       12: 2447:Obj* obj_cdr(Obj* p) {
       12: 2448:    Obj* r = cdr(p);
call    0 returned 12
       12: 2449:    if (r) inc_ref(r);
branch  0 taken 7 (fallthrough)
branch  1 taken 5
call    2 returned 7
       12: 2450:    return r;
        -: 2451:}
        -: 2452:
function list_length called 4 returned 100% blocks executed 100%
        4: 2453:Obj* list_length(Obj* xs) {
        4: 2454:    long n = 0;
        6: 2455:    while (xs && xs->tag == TAG_PAIR) {
branch  0 taken 4 (fallthrough)
branch  1 taken 2
branch  2 taken 2
branch  3 taken 2 (fallthrough)
        2: 2456:        n++;
        2: 2457:        xs = xs->b;
        -: 2458:    }
        4: 2459:    return mk_int(n);
call    0 returned 4
        -: 2460:}
        -: 2461:
function list_map called 7 returned 100% blocks executed 100%
        7: 2462:Obj* list_map(Obj* fn, Obj* xs) {
        7: 2463:    if (!fn) return NULL;
branch  0 taken 1 (fallthrough)
branch  1 taken 6
        6: 2464:    Obj* head = NULL;
        6: 2465:    Obj* tail = NULL;
       63: 2466:    while (xs && xs->tag == TAG_PAIR) {
branch  0 taken 58 (fallthrough)
branch  1 taken 5
branch  2 taken 57
branch  3 taken 1 (fallthrough)
        -: 2467:        Obj* args[1];
       57: 2468:        args[0] = xs->a;
       57: 2469:        Obj* val = call_closure(fn, args, 1);
call    0 returned 57
       57: 2470:        Obj* node = mk_pair(val, NULL);
call    0 returned 57
       57: 2471:        if (!head) {
branch  0 taken 4 (fallthrough)
branch  1 taken 53
        4: 2472:            head = node;
        -: 2473:        } else {
       53: 2474:            tail->b = node;
        -: 2475:        }
       57: 2476:        tail = node;
       57: 2477:        xs = xs->b;
        -: 2478:    }
        6: 2479:    return head;
        -: 2480:}
        -: 2481:
function list_fold called 6 returned 100% blocks executed 100%
        6: 2482:Obj* list_fold(Obj* fn, Obj* init, Obj* xs) {
        6: 2483:    if (!fn) return init;
branch  0 taken 1 (fallthrough)
branch  1 taken 5
        5: 2484:    Obj* acc = init;
      114: 2485:    while (xs && xs->tag == TAG_PAIR) {
branch  0 taken 109 (fallthrough)
branch  1 taken 5
branch  2 taken 109
branch  3 taken 0 (fallthrough)
        -: 2486:        Obj* args[2];
      109: 2487:        args[0] = acc;
      109: 2488:        args[1] = xs->a;
      109: 2489:        acc = call_closure(fn, args, 2);
call    0 returned 109
      109: 2490:        xs = xs->b;
        -: 2491:    }
        5: 2492:    return acc;
        -: 2493:}
        -: 2494:
function list_append called 6 returned 100% blocks executed 90%
        6: 2495:Obj* list_append(Obj* a, Obj* b) {
        6: 2496:    if (!a || a->tag != TAG_PAIR) return b;
branch  0 taken 4 (fallthrough)
branch  1 taken 2
branch  2 taken 0 (fallthrough)
branch  3 taken 4
        -: 2497:    /* Build a copy of list a, then append b */
        4: 2498:    Obj* head = NULL;
        4: 2499:    Obj* tail = NULL;
       59: 2500:    while (a && a->tag == TAG_PAIR) {
branch  0 taken 55 (fallthrough)
branch  1 taken 4
branch  2 taken 55
branch  3 taken 0 (fallthrough)
       55: 2501:        Obj* node = mk_pair(a->a, NULL);
call    0 returned 55
       55: 2502:        if (node->a) inc_ref(node->a);
branch  0 taken 55 (fallthrough)
branch  1 taken 0
call    2 returned 55
       55: 2503:        if (!head) {
branch  0 taken 4 (fallthrough)
branch  1 taken 51
        4: 2504:            head = node;
        -: 2505:        } else {
       51: 2506:            tail->b = node;
        -: 2507:        }
       55: 2508:        tail = node;
       55: 2509:        a = a->b;
        -: 2510:    }
        4: 2511:    if (tail) {
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4: 2512:        tail->b = b;
        4: 2513:        if (b) inc_ref(b);
branch  0 taken 3 (fallthrough)
branch  1 taken 1
call    2 returned 3
        -: 2514:    } else {
    #####: 2515:        head = b;
    #####: 2516:        if (b) inc_ref(b);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
        -: 2517:    }
        4: 2518:    return head;
        -: 2519:}
        -: 2520:
function list_filter called 9 returned 100% blocks executed 100%
        9: 2521:Obj* list_filter(Obj* fn, Obj* xs) {
        9: 2522:    if (!fn) return NULL;
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        8: 2523:    Obj* head = NULL;
        8: 2524:    Obj* tail = NULL;
       29: 2525:    while (xs && obj_tag(xs) == TAG_PAIR) {
branch  0 taken 22 (fallthrough)
branch  1 taken 7
call    2 returned 22
branch  3 taken 21
branch  4 taken 1 (fallthrough)
        -: 2526:        Obj* args[1];
       21: 2527:        args[0] = xs->a;
       21: 2528:        Obj* keep = call_closure(fn, args, 1);
call    0 returned 21
        -: 2529:        /* Non-NULL and non-zero means keep */
       21: 2530:        int should_keep = keep && (obj_tag(keep) != TAG_INT || obj_to_int(keep) != 0);
branch  0 taken 10 (fallthrough)
branch  1 taken 11
call    2 returned 10
branch  3 taken 10 (fallthrough)
branch  4 taken 0
call    5 returned 10
branch  6 taken 10 (fallthrough)
branch  7 taken 0
       21: 2531:        if (keep) dec_ref(keep);
branch  0 taken 10 (fallthrough)
branch  1 taken 11
call    2 returned 10
       21: 2532:        if (should_keep) {
branch  0 taken 10 (fallthrough)
branch  1 taken 11
       10: 2533:            Obj* node = mk_pair(xs->a, NULL);
call    0 returned 10
       10: 2534:            if (xs->a) inc_ref(xs->a);
branch  0 taken 10 (fallthrough)
branch  1 taken 0
call    2 returned 10
       10: 2535:            if (!head) {
branch  0 taken 4 (fallthrough)
branch  1 taken 6
        4: 2536:                head = node;
        -: 2537:            } else {
        6: 2538:                tail->b = node;
        -: 2539:            }
       10: 2540:            tail = node;
        -: 2541:        }
       21: 2542:        xs = xs->b;
        -: 2543:    }
        8: 2544:    return head;
        -: 2545:}
        -: 2546:
function list_reverse called 9 returned 100% blocks executed 100%
        9: 2547:Obj* list_reverse(Obj* xs) {
        9: 2548:    Obj* result = NULL;
      124: 2549:    while (xs && xs->tag == TAG_PAIR) {
branch  0 taken 116 (fallthrough)
branch  1 taken 8
branch  2 taken 115
branch  3 taken 1 (fallthrough)
      115: 2550:        Obj* node = mk_pair(xs->a, result);
call    0 returned 115
      115: 2551:        if (xs->a) inc_ref(xs->a);
branch  0 taken 115 (fallthrough)
branch  1 taken 0
call    2 returned 115
      115: 2552:        result = node;
      115: 2553:        xs = xs->b;
        -: 2554:    }
        9: 2555:    return result;
        -: 2556:}
        -: 2557:
function list_foldr called 3 returned 100% blocks executed 94%
        3: 2558:Obj* list_foldr(Obj* fn, Obj* init, Obj* xs) {
        -: 2559:    /* foldr f init (x:xs) = f x (foldr f init xs) */
       3*: 2560:    if (!fn) return init;
branch  0 taken 0 (fallthrough)
branch  1 taken 3
        3: 2561:    if (!xs || xs->tag != TAG_PAIR) return init;
branch  0 taken 2 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 2
        -: 2562:    /* Recursive approach - build stack then apply */
        2: 2563:    Obj* reversed = list_reverse(xs);
call    0 returned 2
        2: 2564:    Obj* acc = init;
        2: 2565:    if (init) inc_ref(init);
branch  0 taken 2 (fallthrough)
branch  1 taken 0
call    2 returned 2
        2: 2566:    Obj* p = reversed;
        8: 2567:    while (p && p->tag == TAG_PAIR) {
branch  0 taken 6 (fallthrough)
branch  1 taken 2
branch  2 taken 6
branch  3 taken 0 (fallthrough)
        -: 2568:        Obj* args[2];
        6: 2569:        args[0] = p->a;
        6: 2570:        args[1] = acc;
        6: 2571:        Obj* new_acc = call_closure(fn, args, 2);
call    0 returned 6
        6: 2572:        dec_ref(acc);
call    0 returned 6
        6: 2573:        acc = new_acc;
        6: 2574:        p = p->b;
        -: 2575:    }
        2: 2576:    dec_ref(reversed);
call    0 returned 2
        2: 2577:    return acc;
        -: 2578:}
        -: 2579:
        -: 2580:/* Generic Scanners (debug/verification only) */
function scan_obj called 0 returned 0% blocks executed 0%
    #####: 2581:void scan_obj(Obj* x) {
    #####: 2582:    if (!x || x->scan_tag) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2583:    x->scan_tag = 1;
    #####: 2584:    switch (x->tag) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2585:    case TAG_PAIR:
    #####: 2586:        scan_obj(x->a);
call    0 never executed
    #####: 2587:        scan_obj(x->b);
call    0 never executed
    #####: 2588:        break;
    #####: 2589:    case TAG_BOX:
    #####: 2590:        scan_obj((Obj*)x->ptr);
call    0 never executed
    #####: 2591:        break;
    #####: 2592:    case TAG_CLOSURE: {
    #####: 2593:        Closure* c = (Closure*)x->ptr;
    #####: 2594:        if (c && c->captures) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2595:            for (int i = 0; i < c->capture_count; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2596:                scan_obj(c->captures[i]);
call    0 never executed
        -: 2597:            }
        -: 2598:        }
    #####: 2599:        break;
        -: 2600:    }
    #####: 2601:    default:
    #####: 2602:        if (x->tag >= TAG_USER_BASE) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2603:            scan_user_obj(x);
call    0 never executed
        -: 2604:        }
    #####: 2605:        break;
        -: 2606:    }
        -: 2607:}
        -: 2608:
function clear_marks_obj called 0 returned 0% blocks executed 0%
    #####: 2609:void clear_marks_obj(Obj* x) {
    #####: 2610:    if (!x || !x->scan_tag) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2611:    x->scan_tag = 0;
    #####: 2612:    switch (x->tag) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2613:    case TAG_PAIR:
    #####: 2614:        clear_marks_obj(x->a);
call    0 never executed
    #####: 2615:        clear_marks_obj(x->b);
call    0 never executed
    #####: 2616:        break;
    #####: 2617:    case TAG_BOX:
    #####: 2618:        clear_marks_obj((Obj*)x->ptr);
call    0 never executed
    #####: 2619:        break;
    #####: 2620:    case TAG_CLOSURE: {
    #####: 2621:        Closure* c = (Closure*)x->ptr;
    #####: 2622:        if (c && c->captures) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2623:            for (int i = 0; i < c->capture_count; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2624:                clear_marks_obj(c->captures[i]);
call    0 never executed
        -: 2625:            }
        -: 2626:        }
    #####: 2627:        break;
        -: 2628:    }
    #####: 2629:    default:
    #####: 2630:        if (x->tag >= TAG_USER_BASE) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2631:            clear_marks_user_obj(x);
call    0 never executed
        -: 2632:        }
    #####: 2633:        break;
        -: 2634:    }
        -: 2635:}
        -: 2636:
        -: 2637:/* Perceus Reuse Analysis Runtime */
function try_reuse called 0 returned 0% blocks executed 0%
    #####: 2638:Obj* try_reuse(Obj* old, size_t size) {
    #####: 2639:    if (old && old->mark == 1) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 2640:        /* Reusing: release children if this was a pair */
    #####: 2641:        if (old->is_pair) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2642:            if (old->a) dec_ref(old->a);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 2643:            if (old->b) dec_ref(old->b);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 2644:            old->a = NULL;
    #####: 2645:            old->b = NULL;
        -: 2646:        }
    #####: 2647:        return old;
        -: 2648:    }
    #####: 2649:    if (old) dec_ref(old);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 2650:    return malloc(size);
        -: 2651:}
        -: 2652:
function reuse_as_int called 0 returned 0% blocks executed 0%
    #####: 2653:Obj* reuse_as_int(Obj* old, long value) {
    #####: 2654:    Obj* obj = try_reuse(old, sizeof(Obj));
call    0 never executed
    #####: 2655:    if (!obj) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2656:    obj->mark = 1;
    #####: 2657:    obj->scc_id = -1;
    #####: 2658:    obj->is_pair = 0;
    #####: 2659:    obj->scan_tag = 0;
    #####: 2660:    obj->tag = TAG_INT;
    #####: 2661:    obj->generation = _next_generation();
call    0 never executed
    #####: 2662:    obj->i = value;
    #####: 2663:    return obj;
        -: 2664:}
        -: 2665:
function reuse_as_pair called 0 returned 0% blocks executed 0%
    #####: 2666:Obj* reuse_as_pair(Obj* old, Obj* a, Obj* b) {
    #####: 2667:    Obj* obj = try_reuse(old, sizeof(Obj));
call    0 never executed
    #####: 2668:    if (!obj) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2669:    obj->mark = 1;
    #####: 2670:    obj->scc_id = -1;
    #####: 2671:    obj->is_pair = 1;
    #####: 2672:    obj->scan_tag = 0;
    #####: 2673:    obj->tag = TAG_PAIR;
    #####: 2674:    obj->generation = _next_generation();
call    0 never executed
    #####: 2675:    obj->a = a;
    #####: 2676:    obj->b = b;
    #####: 2677:    return obj;
        -: 2678:}
        -: 2679:
        -: 2680:/* ========== Concurrency Runtime ========== */
        -: 2681:/* Thread-safe ownership management with message passing */
        -: 2682:
        -: 2683:#include <pthread.h>
        -: 2684:#include <stdbool.h>
        -: 2685:
        -: 2686:/* === Atomic Reference Counting for Shared Objects === */
        -: 2687:
        -: 2688:/* Atomic increment */
function atomic_inc_ref called 0 returned 0% blocks executed 0%
    #####: 2689:static inline void atomic_inc_ref(Obj* obj) {
    #####: 2690:    if (obj) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2691:        __atomic_add_fetch(&obj->mark, 1, __ATOMIC_SEQ_CST);
        -: 2692:    }
    #####: 2693:}
        -: 2694:
        -: 2695:/* Atomic decrement with potential free */
function atomic_dec_ref called 0 returned 0% blocks executed 0%
    #####: 2696:static inline void atomic_dec_ref(Obj* obj) {
    #####: 2697:    if (obj) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2698:        if (__atomic_sub_fetch(&obj->mark, 1, __ATOMIC_SEQ_CST) == 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2699:            free_obj(obj);
call    0 never executed
        -: 2700:        }
        -: 2701:    }
    #####: 2702:}
        -: 2703:
        -: 2704:/* Try to acquire unique ownership (for in-place updates) */
        -: 2705:static inline bool try_acquire_unique(Obj* obj) {
        -: 2706:    if (!obj) return false;
        -: 2707:    int expected = 1;
        -: 2708:    return __atomic_compare_exchange_n(&obj->mark, &expected, 1,
        -: 2709:        false, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);
        -: 2710:}
        -: 2711:
        -: 2712:/* === Channel Operations with Ownership Transfer === */
        -: 2713:
        -: 2714:typedef struct Channel Channel;
        -: 2715:struct Channel {
        -: 2716:    Obj** buffer;       /* Ring buffer for values */
        -: 2717:    int capacity;       /* Buffer size (0 = unbuffered) */
        -: 2718:    int count;          /* Current number of items */
        -: 2719:    int read_pos;       /* Read position */
        -: 2720:    int write_pos;      /* Write position */
        -: 2721:    Obj* slot;          /* Unbuffered handoff slot */
        -: 2722:    bool has_slot;
        -: 2723:    int waiting_receivers;
        -: 2724:    pthread_mutex_t lock;
        -: 2725:    pthread_cond_t not_empty;
        -: 2726:    pthread_cond_t not_full;
        -: 2727:    bool closed;
        -: 2728:};
        -: 2729:
        -: 2730:/* Create a channel */
function make_channel called 2 returned 100% blocks executed 77%
        2: 2731:Obj* make_channel(int capacity) {
        2: 2732:    Channel* ch = malloc(sizeof(Channel));
       2*: 2733:    if (!ch) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 2734:
        2: 2735:    ch->capacity = capacity;
        2: 2736:    ch->buffer = NULL;
        2: 2737:    if (ch->capacity > 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 2738:        ch->buffer = malloc(sizeof(Obj*) * ch->capacity);
        1: 2739:        if (!ch->buffer) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2740:            free(ch);
    #####: 2741:            return NULL;
        -: 2742:        }
        -: 2743:    }
        2: 2744:    ch->count = 0;
        2: 2745:    ch->read_pos = 0;
        2: 2746:    ch->write_pos = 0;
        2: 2747:    ch->slot = NULL;
        2: 2748:    ch->has_slot = false;
        2: 2749:    ch->waiting_receivers = 0;
        2: 2750:    ch->closed = false;
        -: 2751:
        2: 2752:    pthread_mutex_init(&ch->lock, NULL);
call    0 returned 2
        2: 2753:    pthread_cond_init(&ch->not_empty, NULL);
call    0 returned 2
        2: 2754:    pthread_cond_init(&ch->not_full, NULL);
call    0 returned 2
        -: 2755:
        2: 2756:    Obj* obj = malloc(sizeof(Obj));
        2: 2757:    if (!obj) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####: 2758:        free(ch->buffer);
    #####: 2759:        free(ch);
    #####: 2760:        return NULL;
        -: 2761:    }
        2: 2762:    obj->mark = 1;
        2: 2763:    obj->scc_id = -1;
        2: 2764:    obj->is_pair = 0;
        2: 2765:    obj->scan_tag = 0;
        2: 2766:    obj->tag = TAG_CHANNEL;
        2: 2767:    obj->generation = _next_generation();
call    0 returned 2
        2: 2768:    obj->ptr = ch;
        -: 2769:
        2: 2770:    return obj;
        -: 2771:}
        -: 2772:
function channel_create called 0 returned 0% blocks executed 0%
    #####: 2773:Obj* channel_create(int buffered) {
    #####: 2774:    return make_channel(buffered);
call    0 never executed
        -: 2775:}
        -: 2776:
function channel_payload called 4 returned 100% blocks executed 80%
        4: 2777:static Channel* channel_payload(Obj* ch_obj) {
       4*: 2778:    if (!ch_obj || ch_obj->tag != TAG_CHANNEL) return NULL;
branch  0 taken 4 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 4
        4: 2779:    return (Channel*)ch_obj->ptr;
        -: 2780:}
        -: 2781:
        -: 2782:/* Send value through channel (TRANSFERS OWNERSHIP) */
        -: 2783:/* After send, caller should NOT use or free the value */
function channel_send called 1 returned 100% blocks executed 55%
        1: 2784:int channel_send(Obj* ch_obj, Obj* value) {
        1: 2785:    Channel* ch = channel_payload(ch_obj);
call    0 returned 1
       1*: 2786:    if (!ch || ch->closed) return false;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        -: 2787:
        1: 2788:    pthread_mutex_lock(&ch->lock);
call    0 returned 1
        -: 2789:
        1: 2790:    if (ch->capacity == 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        2: 2791:        while (ch->waiting_receivers == 0 && !ch->closed) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
branch  2 taken 1
branch  3 taken 0 (fallthrough)
        1: 2792:            pthread_cond_wait(&ch->not_full, &ch->lock);
call    0 returned 1
        -: 2793:        }
        1: 2794:        if (ch->closed) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2795:            pthread_mutex_unlock(&ch->lock);
call    0 never executed
    #####: 2796:            return false;
        -: 2797:        }
       1*: 2798:        while (ch->has_slot && !ch->closed) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 2799:            pthread_cond_wait(&ch->not_full, &ch->lock);
call    0 never executed
        -: 2800:        }
        1: 2801:        if (ch->closed) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2802:            pthread_mutex_unlock(&ch->lock);
call    0 never executed
    #####: 2803:            return false;
        -: 2804:        }
        1: 2805:        ch->slot = value;
        1: 2806:        ch->has_slot = true;
        1: 2807:        pthread_cond_signal(&ch->not_empty);
call    0 returned 1
        2: 2808:        while (ch->has_slot && !ch->closed) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
branch  2 taken 1
branch  3 taken 0 (fallthrough)
        1: 2809:            pthread_cond_wait(&ch->not_full, &ch->lock);
call    0 returned 1
        -: 2810:        }
        1: 2811:        pthread_mutex_unlock(&ch->lock);
call    0 returned 1
        1: 2812:        return !ch->closed;
        -: 2813:    }
        -: 2814:
        -: 2815:    /* Wait for space */
    #####: 2816:    while (ch->count >= ch->capacity && !ch->closed) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 2817:        pthread_cond_wait(&ch->not_full, &ch->lock);
call    0 never executed
        -: 2818:    }
        -: 2819:
    #####: 2820:    if (ch->closed) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2821:        pthread_mutex_unlock(&ch->lock);
call    0 never executed
    #####: 2822:        return false;
        -: 2823:    }
        -: 2824:
        -: 2825:    /* Transfer ownership: no inc_ref needed, sender gives up value */
    #####: 2826:    ch->buffer[ch->write_pos] = value;
    #####: 2827:    ch->write_pos = (ch->write_pos + 1) % ch->capacity;
    #####: 2828:    ch->count++;
        -: 2829:
    #####: 2830:    pthread_cond_signal(&ch->not_empty);
call    0 never executed
    #####: 2831:    pthread_mutex_unlock(&ch->lock);
call    0 never executed
        -: 2832:
    #####: 2833:    return true;
        -: 2834:}
        -: 2835:
        -: 2836:/* Receive value from channel (RECEIVES OWNERSHIP) */
        -: 2837:/* Caller becomes owner, must free when done */
function channel_recv called 1 returned 100% blocks executed 52%
        1: 2838:Obj* channel_recv(Obj* ch_obj) {
        1: 2839:    Channel* ch = channel_payload(ch_obj);
call    0 returned 1
       1*: 2840:    if (!ch) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 2841:
        1: 2842:    pthread_mutex_lock(&ch->lock);
call    0 returned 1
        -: 2843:
        1: 2844:    if (ch->capacity == 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 2845:        ch->waiting_receivers++;
        1: 2846:        pthread_cond_signal(&ch->not_full);
call    0 returned 1
        2: 2847:        while (!ch->has_slot && !ch->closed) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
branch  2 taken 1
branch  3 taken 0 (fallthrough)
        1: 2848:            pthread_cond_wait(&ch->not_empty, &ch->lock);
call    0 returned 1
        -: 2849:        }
        1: 2850:        ch->waiting_receivers--;
        1: 2851:        if (!ch->has_slot) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2852:            pthread_mutex_unlock(&ch->lock);
call    0 never executed
    #####: 2853:            return NULL;
        -: 2854:        }
        1: 2855:        Obj* value = ch->slot;
        1: 2856:        ch->slot = NULL;
        1: 2857:        ch->has_slot = false;
        1: 2858:        pthread_cond_signal(&ch->not_full);
call    0 returned 1
        1: 2859:        pthread_mutex_unlock(&ch->lock);
call    0 returned 1
        1: 2860:        return value;
        -: 2861:    }
        -: 2862:
        -: 2863:    /* Wait for data */
    #####: 2864:    while (ch->count == 0 && !ch->closed) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 2865:        pthread_cond_wait(&ch->not_empty, &ch->lock);
call    0 never executed
        -: 2866:    }
        -: 2867:
    #####: 2868:    if (ch->count == 0) {
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2869:        /* Channel closed and empty */
    #####: 2870:        pthread_mutex_unlock(&ch->lock);
call    0 never executed
    #####: 2871:        return NULL;
        -: 2872:    }
        -: 2873:
        -: 2874:    /* Transfer ownership: receiver now owns the value */
    #####: 2875:    Obj* value = ch->buffer[ch->read_pos];
    #####: 2876:    ch->read_pos = (ch->read_pos + 1) % ch->capacity;
    #####: 2877:    ch->count--;
        -: 2878:
    #####: 2879:    pthread_cond_signal(&ch->not_full);
call    0 never executed
    #####: 2880:    pthread_mutex_unlock(&ch->lock);
call    0 never executed
        -: 2881:
    #####: 2882:    return value;  /* Caller owns this */
        -: 2883:}
        -: 2884:
        -: 2885:/* Close a channel */
function channel_close called 0 returned 0% blocks executed 0%
    #####: 2886:void channel_close(Obj* ch_obj) {
    #####: 2887:    Channel* ch = channel_payload(ch_obj);
call    0 never executed
    #####: 2888:    if (!ch) return;
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2889:
    #####: 2890:    pthread_mutex_lock(&ch->lock);
call    0 never executed
    #####: 2891:    ch->closed = true;
    #####: 2892:    pthread_cond_broadcast(&ch->not_empty);
call    0 never executed
    #####: 2893:    pthread_cond_broadcast(&ch->not_full);
call    0 never executed
    #####: 2894:    pthread_mutex_unlock(&ch->lock);
call    0 never executed
        -: 2895:}
        -: 2896:
        -: 2897:/* Free a channel */
function free_channel_obj called 2 returned 100% blocks executed 67%
        2: 2898:void free_channel_obj(Obj* ch_obj) {
        2: 2899:    Channel* ch = channel_payload(ch_obj);
call    0 returned 2
       2*: 2900:    if (!ch) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 2901:
        -: 2902:    /* Free any remaining values (ownership cleanup) */
        2: 2903:    if (ch->capacity == 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 1
       1*: 2904:        if (ch->has_slot && ch->slot) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 2905:            dec_ref(ch->slot);
call    0 never executed
        -: 2906:        }
        -: 2907:    } else {
        1: 2908:        while (ch->count > 0) {
branch  0 taken 0
branch  1 taken 1 (fallthrough)
    #####: 2909:            Obj* val = ch->buffer[ch->read_pos];
    #####: 2910:            if (val) dec_ref(val);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 2911:            ch->read_pos = (ch->read_pos + 1) % ch->capacity;
    #####: 2912:            ch->count--;
        -: 2913:        }
        -: 2914:    }
        -: 2915:
        2: 2916:    free(ch->buffer);
        2: 2917:    pthread_mutex_destroy(&ch->lock);
call    0 returned 2
        2: 2918:    pthread_cond_destroy(&ch->not_empty);
call    0 returned 2
        2: 2919:    pthread_cond_destroy(&ch->not_full);
call    0 returned 2
        2: 2920:    free(ch);
        2: 2921:    if (ch_obj) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2: 2922:        ch_obj->ptr = NULL;
        -: 2923:    }
        -: 2924:}
        -: 2925:
        -: 2926:/* === Goroutine Spawning === */
        -: 2927:
        -: 2928:typedef struct GoroutineArg GoroutineArg;
        -: 2929:struct GoroutineArg {
        -: 2930:    Obj* closure;       /* The closure to run */
        -: 2931:    Obj** captured;     /* Captured variables (with inc_ref'd ownership) */
        -: 2932:    int captured_count;
        -: 2933:};
        -: 2934:
        -: 2935:/* Thread entry point */
function goroutine_entry called 0 returned 0% blocks executed 0%
    #####: 2936:static void* goroutine_entry(void* arg) {
    #####: 2937:    GoroutineArg* ga = (GoroutineArg*)arg;
        -: 2938:
        -: 2939:    /* Call the closure */
    #####: 2940:    if (ga->closure) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2941:        call_closure(ga->closure, NULL, 0);
call    0 never executed
    #####: 2942:        dec_ref(ga->closure);
call    0 never executed
        -: 2943:    }
        -: 2944:
        -: 2945:    /* Release captured variables */
    #####: 2946:    for (int i = 0; i < ga->captured_count; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2947:        if (ga->captured[i]) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2948:            atomic_dec_ref(ga->captured[i]);
call    0 never executed
        -: 2949:        }
        -: 2950:    }
        -: 2951:
    #####: 2952:    free(ga->captured);
    #####: 2953:    free(ga);
    #####: 2954:    return NULL;
        -: 2955:}
        -: 2956:
        -: 2957:/* Spawn a goroutine */
function spawn_goroutine called 0 returned 0% blocks executed 0%
    #####: 2958:void spawn_goroutine(Obj* closure, Obj** captured, int count) {
    #####: 2959:    GoroutineArg* arg = malloc(sizeof(GoroutineArg));
    #####: 2960:    if (!arg) return;
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 2961:
        -: 2962:    /* Transfer ownership of closure to goroutine */
    #####: 2963:    arg->closure = closure;
    #####: 2964:    inc_ref(closure);
call    0 never executed
        -: 2965:
        -: 2966:    /* Copy and increment captured variables (they become shared) */
    #####: 2967:    arg->captured_count = count;
    #####: 2968:    arg->captured = malloc(sizeof(Obj*) * count);
    #####: 2969:    for (int i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 2970:        arg->captured[i] = captured[i];
    #####: 2971:        if (captured[i]) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 2972:            atomic_inc_ref(captured[i]);
call    0 never executed
        -: 2973:        }
        -: 2974:    }
        -: 2975:
        -: 2976:    pthread_t thread;
    #####: 2977:    pthread_create(&thread, NULL, goroutine_entry, arg);
call    0 never executed
    #####: 2978:    pthread_detach(thread);  /* Don't wait for completion */
call    0 never executed
        -: 2979:}
        -: 2980:
        -: 2981:/* === Atom (Atomic Reference) Operations === */
        -: 2982:
        -: 2983:typedef struct Atom Atom;
        -: 2984:struct Atom {
        -: 2985:    Obj* value;
        -: 2986:    pthread_mutex_t lock;
        -: 2987:};
        -: 2988:
        -: 2989:/* Create an atom */
function make_atom called 1 returned 100% blocks executed 67%
        1: 2990:Obj* make_atom(Obj* initial) {
        1: 2991:    Atom* a = malloc(sizeof(Atom));
       1*: 2992:    if (!a) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 2993:
        1: 2994:    a->value = initial;
        1: 2995:    if (initial) inc_ref(initial);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
        1: 2996:    pthread_mutex_init(&a->lock, NULL);
call    0 returned 1
        -: 2997:
        1: 2998:    Obj* obj = malloc(sizeof(Obj));
        1: 2999:    if (!obj) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3000:        if (initial) dec_ref(initial);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 3001:        free(a);
    #####: 3002:        return NULL;
        -: 3003:    }
        1: 3004:    obj->mark = 1;
        1: 3005:    obj->scc_id = -1;
        1: 3006:    obj->is_pair = 0;
        1: 3007:    obj->scan_tag = 0;
        1: 3008:    obj->tag = TAG_ATOM;
        1: 3009:    obj->generation = _next_generation();
call    0 returned 1
        1: 3010:    obj->ptr = a;
        -: 3011:
        1: 3012:    return obj;
        -: 3013:}
        -: 3014:
function atom_create called 0 returned 0% blocks executed 0%
    #####: 3015:Obj* atom_create(Obj* initial) {
    #####: 3016:    return make_atom(initial);
call    0 never executed
        -: 3017:}
        -: 3018:
function atom_payload called 1 returned 100% blocks executed 80%
        1: 3019:static Atom* atom_payload(Obj* atom_obj) {
       1*: 3020:    if (!atom_obj || atom_obj->tag != TAG_ATOM) return NULL;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        1: 3021:    return (Atom*)atom_obj->ptr;
        -: 3022:}
        -: 3023:
        -: 3024:/* Dereference atom (read current value) */
function atom_deref called 0 returned 0% blocks executed 0%
    #####: 3025:Obj* atom_deref(Obj* atom_obj) {
    #####: 3026:    Atom* a = atom_payload(atom_obj);
call    0 never executed
    #####: 3027:    if (!a) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3028:
    #####: 3029:    pthread_mutex_lock(&a->lock);
call    0 never executed
    #####: 3030:    Obj* val = a->value;
    #####: 3031:    if (val) inc_ref(val);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 3032:    pthread_mutex_unlock(&a->lock);
call    0 never executed
        -: 3033:
    #####: 3034:    return val;
        -: 3035:}
        -: 3036:
        -: 3037:/* Reset atom to new value */
function atom_reset called 0 returned 0% blocks executed 0%
    #####: 3038:Obj* atom_reset(Obj* atom_obj, Obj* new_val) {
    #####: 3039:    Atom* a = atom_payload(atom_obj);
call    0 never executed
    #####: 3040:    if (!a) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3041:
    #####: 3042:    pthread_mutex_lock(&a->lock);
call    0 never executed
    #####: 3043:    Obj* old = a->value;
    #####: 3044:    a->value = new_val;
    #####: 3045:    if (new_val) inc_ref(new_val);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 3046:    if (old) dec_ref(old);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 3047:    pthread_mutex_unlock(&a->lock);
call    0 never executed
        -: 3048:
    #####: 3049:    if (new_val) inc_ref(new_val);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 3050:    return new_val;
        -: 3051:}
        -: 3052:
        -: 3053:/* Swap atom value using function */
function atom_swap called 0 returned 0% blocks executed 0%
    #####: 3054:Obj* atom_swap(Obj* atom_obj, Obj* fn) {
    #####: 3055:    Atom* a = atom_payload(atom_obj);
call    0 never executed
    #####: 3056:    if (!a || !fn) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3057:
    #####: 3058:    pthread_mutex_lock(&a->lock);
call    0 never executed
    #####: 3059:    Obj* old = a->value;
        -: 3060:
        -: 3061:    /* Call function with current value */
    #####: 3062:    Obj* args[1] = { old };
    #####: 3063:    Obj* new_val = call_closure(fn, args, 1);
call    0 never executed
        -: 3064:
    #####: 3065:    a->value = new_val;
    #####: 3066:    if (old) dec_ref(old);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
        -: 3067:
    #####: 3068:    pthread_mutex_unlock(&a->lock);
call    0 never executed
        -: 3069:
    #####: 3070:    if (new_val) inc_ref(new_val);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 3071:    return new_val;
        -: 3072:}
        -: 3073:
        -: 3074:/* Compare-and-set */
function atom_cas called 0 returned 0% blocks executed 0%
    #####: 3075:Obj* atom_cas(Obj* atom_obj, Obj* expected, Obj* new_val) {
    #####: 3076:    Atom* a = atom_payload(atom_obj);
call    0 never executed
    #####: 3077:    if (!a) return mk_int(0);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
        -: 3078:
    #####: 3079:    pthread_mutex_lock(&a->lock);
call    0 never executed
    #####: 3080:    bool success = (a->value == expected);
    #####: 3081:    if (success) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3082:        Obj* old = a->value;
    #####: 3083:        a->value = new_val;
    #####: 3084:        if (new_val) inc_ref(new_val);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 3085:        if (old) dec_ref(old);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
        -: 3086:    }
    #####: 3087:    pthread_mutex_unlock(&a->lock);
call    0 never executed
        -: 3088:
    #####: 3089:    return mk_int(success ? 1 : 0);
call    0 never executed
        -: 3090:}
        -: 3091:
function atom_compare_and_set called 0 returned 0% blocks executed 0%
    #####: 3092:Obj* atom_compare_and_set(Obj* atom, Obj* expected, Obj* new_val) {
    #####: 3093:    return atom_cas(atom, expected, new_val);
call    0 never executed
        -: 3094:}
        -: 3095:
        -: 3096:/* Free atom */
function free_atom_obj called 1 returned 100% blocks executed 89%
        1: 3097:void free_atom_obj(Obj* atom_obj) {
        1: 3098:    Atom* a = atom_payload(atom_obj);
call    0 returned 1
       1*: 3099:    if (!a) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 3100:
        1: 3101:    if (a->value) dec_ref(a->value);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
        1: 3102:    pthread_mutex_destroy(&a->lock);
call    0 returned 1
        1: 3103:    free(a);
        1: 3104:    if (atom_obj) atom_obj->ptr = NULL;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3105:}
        -: 3106:
        -: 3107:/* === Thread Operations (with join support) === */
        -: 3108:
        -: 3109:typedef struct ThreadHandle ThreadHandle;
        -: 3110:struct ThreadHandle {
        -: 3111:    pthread_t thread;
        -: 3112:    Obj* result;
        -: 3113:    bool done;
        -: 3114:    pthread_mutex_t lock;
        -: 3115:    pthread_cond_t cond;
        -: 3116:};
        -: 3117:
        -: 3118:typedef struct ThreadArg ThreadArg;
        -: 3119:struct ThreadArg {
        -: 3120:    Obj* closure;
        -: 3121:    ThreadHandle* handle;
        -: 3122:};
        -: 3123:
        -: 3124:/* Thread entry point */
function thread_entry called 1 returned 100% blocks executed 100%
        1: 3125:static void* thread_entry(void* arg) {
        1: 3126:    ThreadArg* ta = (ThreadArg*)arg;
        -: 3127:
        -: 3128:    /* Call the closure */
        1: 3129:    Obj* result = NULL;
        1: 3130:    if (ta->closure) {
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 3131:        result = call_closure(ta->closure, NULL, 0);
call    0 returned 1
        1: 3132:        dec_ref(ta->closure);
call    0 returned 1
        -: 3133:    }
        -: 3134:
        -: 3135:    /* Store result and signal completion */
        1: 3136:    pthread_mutex_lock(&ta->handle->lock);
call    0 returned 1
        1: 3137:    ta->handle->result = result;
        1: 3138:    ta->handle->done = true;
        1: 3139:    pthread_cond_signal(&ta->handle->cond);
call    0 returned 1
        1: 3140:    pthread_mutex_unlock(&ta->handle->lock);
call    0 returned 1
        -: 3141:
        1: 3142:    free(ta);
        1: 3143:    return NULL;
        -: 3144:}
        -: 3145:
        -: 3146:/* Spawn a thread (returns handle for joining) */
function spawn_thread called 1 returned 100% blocks executed 79%
        1: 3147:Obj* spawn_thread(Obj* closure) {
        1: 3148:    ThreadHandle* h = malloc(sizeof(ThreadHandle));
       1*: 3149:    if (!h) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 3150:
        1: 3151:    h->result = NULL;
        1: 3152:    h->done = false;
        1: 3153:    pthread_mutex_init(&h->lock, NULL);
call    0 returned 1
        1: 3154:    pthread_cond_init(&h->cond, NULL);
call    0 returned 1
        -: 3155:
        1: 3156:    ThreadArg* arg = malloc(sizeof(ThreadArg));
        1: 3157:    if (!arg) {
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 3158:        free(h);
    #####: 3159:        return NULL;
        -: 3160:    }
        -: 3161:
        1: 3162:    arg->closure = closure;
        1: 3163:    if (closure) inc_ref(closure);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
        1: 3164:    arg->handle = h;
        -: 3165:
        1: 3166:    pthread_create(&h->thread, NULL, thread_entry, arg);
call    0 returned 1
        -: 3167:
        -: 3168:    /* Wrap handle in Obj */
        1: 3169:    Obj* obj = malloc(sizeof(Obj));
       1*: 3170:    if (!obj) return NULL;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        1: 3171:    obj->mark = 1;
        1: 3172:    obj->scc_id = -1;
        1: 3173:    obj->is_pair = 0;
        1: 3174:    obj->scan_tag = 0;
        1: 3175:    obj->tag = TAG_THREAD;
        1: 3176:    obj->generation = _next_generation();
call    0 returned 1
        1: 3177:    obj->ptr = h;
        -: 3178:
        1: 3179:    return obj;
        -: 3180:}
        -: 3181:
function thread_create called 0 returned 0% blocks executed 0%
    #####: 3182:Obj* thread_create(Obj* closure) {
    #####: 3183:    return spawn_thread(closure);
call    0 never executed
        -: 3184:}
        -: 3185:
function thread_payload called 1 returned 100% blocks executed 80%
        1: 3186:static ThreadHandle* thread_payload(Obj* thread_obj) {
       1*: 3187:    if (!thread_obj || thread_obj->tag != TAG_THREAD) return NULL;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        1: 3188:    return (ThreadHandle*)thread_obj->ptr;
        -: 3189:}
        -: 3190:
        -: 3191:/* Join thread and get result */
function thread_join called 0 returned 0% blocks executed 0%
    #####: 3192:Obj* thread_join(Obj* thread_obj) {
    #####: 3193:    ThreadHandle* h = thread_payload(thread_obj);
call    0 never executed
    #####: 3194:    if (!h) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3195:
    #####: 3196:    pthread_mutex_lock(&h->lock);
call    0 never executed
    #####: 3197:    while (!h->done) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3198:        pthread_cond_wait(&h->cond, &h->lock);
call    0 never executed
        -: 3199:    }
    #####: 3200:    Obj* result = h->result;
    #####: 3201:    if (result) inc_ref(result);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
    #####: 3202:    pthread_mutex_unlock(&h->lock);
call    0 never executed
        -: 3203:
    #####: 3204:    return result;
        -: 3205:}
        -: 3206:
        -: 3207:/* Free thread handle */
function free_thread_obj called 1 returned 100% blocks executed 91%
        1: 3208:void free_thread_obj(Obj* thread_obj) {
        1: 3209:    ThreadHandle* h = thread_payload(thread_obj);
call    0 returned 1
       1*: 3210:    if (!h) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 3211:
        1: 3212:    pthread_join(h->thread, NULL);
call    0 returned 1
        1: 3213:    if (h->result) dec_ref(h->result);
branch  0 taken 1 (fallthrough)
branch  1 taken 0
call    2 returned 1
        1: 3214:    pthread_mutex_destroy(&h->lock);
call    0 returned 1
        1: 3215:    pthread_cond_destroy(&h->cond);
call    0 returned 1
        1: 3216:    free(h);
        1: 3217:    if (thread_obj) thread_obj->ptr = NULL;
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -: 3218:}
        -: 3219:
        -: 3220:/* ========== Destination-Passing Style Runtime ========== */
        -: 3221:/* Pre-allocate destination and pass it down */
        -: 3222:
        -: 3223:/* Map with destination passing - writes result into dest */
function map_into called 0 returned 0% blocks executed 0%
    #####: 3224:void map_into(Obj** dest, Obj* (*f)(Obj*), Obj* xs) {
    #####: 3225:    if (!xs || !dest) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3226:
    #####: 3227:    Obj** current = dest;
    #####: 3228:    while (xs && xs->is_pair) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 3229:        Obj* mapped = f(xs->a);
call    0 never executed
        -: 3230:
        -: 3231:        /* Allocate directly into destination chain */
    #####: 3232:        *current = mk_pair(mapped, NULL);
call    0 never executed
    #####: 3233:        current = &((*current)->b);
        -: 3234:
    #####: 3235:        xs = xs->b;
        -: 3236:    }
    #####: 3237:    *current = NULL;  /* Terminate list */
        -: 3238:}
        -: 3239:
        -: 3240:/* Filter with destination passing */
function filter_into called 0 returned 0% blocks executed 0%
    #####: 3241:void filter_into(Obj** dest, int (*pred)(Obj*), Obj* xs) {
    #####: 3242:    if (!xs || !dest) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
        -: 3243:
    #####: 3244:    Obj** current = dest;
    #####: 3245:    while (xs && xs->is_pair) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 3246:        if (pred(xs->a)) {
call    0 never executed
branch  1 never executed (fallthrough)
branch  2 never executed
    #####: 3247:            *current = mk_pair(xs->a, NULL);
call    0 never executed
    #####: 3248:            inc_ref(xs->a);
call    0 never executed
    #####: 3249:            current = &((*current)->b);
        -: 3250:        }
    #####: 3251:        xs = xs->b;
        -: 3252:    }
    #####: 3253:    *current = NULL;
        -: 3254:}
        -: 3255:
        -: 3256:/* Append with destination passing - avoids intermediate allocations */
function append_into called 0 returned 0% blocks executed 0%
    #####: 3257:void append_into(Obj** dest, Obj* xs, Obj* ys) {
    #####: 3258:    if (!dest) return;
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3259:
    #####: 3260:    Obj** current = dest;
        -: 3261:
        -: 3262:    /* Copy first list */
    #####: 3263:    while (xs && xs->is_pair) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed
branch  3 never executed (fallthrough)
    #####: 3264:        *current = mk_pair(xs->a, NULL);
call    0 never executed
    #####: 3265:        inc_ref(xs->a);
call    0 never executed
    #####: 3266:        current = &((*current)->b);
    #####: 3267:        xs = xs->b;
        -: 3268:    }
        -: 3269:
        -: 3270:    /* Append second list (can share structure) */
    #####: 3271:    *current = ys;
    #####: 3272:    if (ys) inc_ref(ys);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
        -: 3273:}
        -: 3274:
        -: 3275:/* Type-Aware Scanner for List */
        -: 3276:/* Note: ASAP uses compile-time free injection, not runtime GC */
function scan_List called 0 returned 0% blocks executed 0%
    #####: 3277:void scan_List(Obj* x) {
    #####: 3278:    if (!x || x->scan_tag) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3279:    x->scan_tag = 1;
    #####: 3280:    if (x->is_pair) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3281:        scan_List(x->a);
call    0 never executed
    #####: 3282:        scan_List(x->b);
call    0 never executed
        -: 3283:    }
        -: 3284:}
        -: 3285:
function clear_marks_List called 0 returned 0% blocks executed 0%
    #####: 3286:void clear_marks_List(Obj* x) {
    #####: 3287:    if (!x || !x->scan_tag) return;
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
    #####: 3288:    x->scan_tag = 0;
    #####: 3289:    if (x->is_pair) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3290:        clear_marks_List(x->a);
call    0 never executed
    #####: 3291:        clear_marks_List(x->b);
call    0 never executed
        -: 3292:    }
        -: 3293:}
        -: 3294:
        -: 3295:/* Type-Aware Release Functions */
        -: 3296:/* Automatically skip weak fields (back-edges) to prevent double-free */
        -: 3297:
function release_user_obj called 0 returned 0% blocks executed 0%
    #####: 3298:void release_user_obj(Obj* obj) { (void)obj; }
        -: 3299:
        -: 3300:/* Type Constructors */
        -: 3301:
        -: 3302:/* Field Accessors */
        -: 3303:/* Getters for weak fields do not increment reference count */
        -: 3304:/* Setters for strong fields manage reference counts automatically */
        -: 3305:
function scan_user_obj called 0 returned 0% blocks executed 0%
    #####: 3306:void scan_user_obj(Obj* obj) { (void)obj; }
function clear_marks_user_obj called 0 returned 0% blocks executed 0%
    #####: 3307:void clear_marks_user_obj(Obj* obj) { (void)obj; }
        -: 3308:
        -: 3309:/* ========== Exception Handling Runtime ========== */
        -: 3310:/* ASAP-compatible exception handling with deterministic cleanup */
        -: 3311:/* Uses setjmp/longjmp for non-local control flow */
        -: 3312:
        -: 3313:#include <setjmp.h>
        -: 3314:
        -: 3315:/* Exception context for stack unwinding */
        -: 3316:typedef struct ExceptionContext ExceptionContext;
        -: 3317:struct ExceptionContext {
        -: 3318:    jmp_buf jump_buffer;
        -: 3319:    Obj* exception_value;
        -: 3320:    ExceptionContext* parent;
        -: 3321:    void** cleanup_stack;
        -: 3322:    int cleanup_count;
        -: 3323:    int cleanup_capacity;
        -: 3324:};
        -: 3325:
        -: 3326:/* Thread-local exception context stack */
        -: 3327:static __thread ExceptionContext* g_exception_ctx = NULL;
        -: 3328:
        -: 3329:/* Push a new exception context (entering try block) */
function exception_push called 0 returned 0% blocks executed 0%
    #####: 3330:static ExceptionContext* exception_push(void) {
    #####: 3331:    ExceptionContext* ctx = malloc(sizeof(ExceptionContext));
    #####: 3332:    if (!ctx) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3333:    ctx->exception_value = NULL;
    #####: 3334:    ctx->parent = g_exception_ctx;
    #####: 3335:    ctx->cleanup_stack = NULL;
    #####: 3336:    ctx->cleanup_count = 0;
    #####: 3337:    ctx->cleanup_capacity = 0;
    #####: 3338:    g_exception_ctx = ctx;
    #####: 3339:    return ctx;
        -: 3340:}
        -: 3341:
        -: 3342:/* Pop exception context (exiting try block normally) */
function exception_pop called 0 returned 0% blocks executed 0%
    #####: 3343:void exception_pop(void) {
    #####: 3344:    if (!g_exception_ctx) return;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3345:    ExceptionContext* ctx = g_exception_ctx;
    #####: 3346:    g_exception_ctx = ctx->parent;
    #####: 3347:    free(ctx->cleanup_stack);
    #####: 3348:    free(ctx);
        -: 3349:}
        -: 3350:
        -: 3351:/* Register a value for cleanup during unwinding */
function exception_register_cleanup called 0 returned 0% blocks executed 0%
    #####: 3352:void exception_register_cleanup(void* ptr) {
    #####: 3353:    if (!g_exception_ctx) return;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3354:    ExceptionContext* ctx = g_exception_ctx;
    #####: 3355:    if (ctx->cleanup_count >= ctx->cleanup_capacity) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3356:        int new_cap = ctx->cleanup_capacity == 0 ? 8 : ctx->cleanup_capacity * 2;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3357:        void** new_stack = realloc(ctx->cleanup_stack, new_cap * sizeof(void*));
    #####: 3358:        if (!new_stack) return;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3359:        ctx->cleanup_stack = new_stack;
    #####: 3360:        ctx->cleanup_capacity = new_cap;
        -: 3361:    }
    #####: 3362:    ctx->cleanup_stack[ctx->cleanup_count++] = ptr;
        -: 3363:}
        -: 3364:
        -: 3365:/* Unregister a value (it was freed normally) */
function exception_unregister_cleanup called 0 returned 0% blocks executed 0%
    #####: 3366:void exception_unregister_cleanup(void* ptr) {
    #####: 3367:    if (!g_exception_ctx) return;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3368:    ExceptionContext* ctx = g_exception_ctx;
    #####: 3369:    for (int i = ctx->cleanup_count - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3370:        if (ctx->cleanup_stack[i] == ptr) {
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3371:            /* Remove by shifting */
    #####: 3372:            for (int j = i; j < ctx->cleanup_count - 1; j++) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3373:                ctx->cleanup_stack[j] = ctx->cleanup_stack[j + 1];
        -: 3374:            }
    #####: 3375:            ctx->cleanup_count--;
    #####: 3376:            return;
        -: 3377:        }
        -: 3378:    }
        -: 3379:}
        -: 3380:
        -: 3381:/* Perform cleanup during unwinding */
function exception_cleanup called 0 returned 0% blocks executed 0%
    #####: 3382:void exception_cleanup(ExceptionContext* ctx) {
    #####: 3383:    if (!ctx) return;
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3384:    /* Free in reverse order (LIFO) */
    #####: 3385:    for (int i = ctx->cleanup_count - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed (fallthrough)
    #####: 3386:        if (ctx->cleanup_stack[i]) {
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3387:            dec_ref((Obj*)ctx->cleanup_stack[i]);
call    0 never executed
        -: 3388:        }
        -: 3389:    }
    #####: 3390:    ctx->cleanup_count = 0;
        -: 3391:}
        -: 3392:
        -: 3393:/* Throw an exception */
function exception_throw called 0 returned 0% blocks executed 0%
    #####: 3394:void exception_throw(Obj* value) {
    #####: 3395:    if (!g_exception_ctx) {
branch  0 never executed (fallthrough)
branch  1 never executed
        -: 3396:        /* No handler - print and abort */
    #####: 3397:        fprintf(stderr, "Uncaught exception: ");
call    0 never executed
    #####: 3398:        if (value && value->tag == TAG_ERROR && value->ptr) {
branch  0 never executed (fallthrough)
branch  1 never executed
branch  2 never executed (fallthrough)
branch  3 never executed
branch  4 never executed (fallthrough)
branch  5 never executed
    #####: 3399:            fprintf(stderr, "%s\n", (char*)value->ptr);
call    0 never executed
        -: 3400:        } else {
    #####: 3401:            fprintf(stderr, "<unknown>\n");
call    0 never executed
        -: 3402:        }
    #####: 3403:        abort();
call    0 never executed
        -: 3404:    }
        -: 3405:
    #####: 3406:    ExceptionContext* ctx = g_exception_ctx;
    #####: 3407:    ctx->exception_value = value;
    #####: 3408:    if (value) inc_ref(value);
branch  0 never executed (fallthrough)
branch  1 never executed
call    2 never executed
        -: 3409:
        -: 3410:    /* Cleanup current context */
    #####: 3411:    exception_cleanup(ctx);
call    0 never executed
        -: 3412:
        -: 3413:    /* Jump to handler */
    #####: 3414:    longjmp(ctx->jump_buffer, 1);
        -: 3415:}
        -: 3416:
        -: 3417:/* Get the current exception value */
function exception_get_value called 0 returned 0% blocks executed 0%
    #####: 3418:Obj* exception_get_value(void) {
    #####: 3419:    if (!g_exception_ctx) return NULL;
branch  0 never executed (fallthrough)
branch  1 never executed
    #####: 3420:    return g_exception_ctx->exception_value;
        -: 3421:}
        -: 3422:
        -: 3423:/* Macros for try/catch */
        -: 3424:#define TRY_BEGIN() do { \
        -: 3425:    ExceptionContext* _exc_ctx = exception_push(); \
        -: 3426:    if (_exc_ctx && setjmp(_exc_ctx->jump_buffer) == 0) {
        -: 3427:
        -: 3428:#define TRY_CATCH(var) \
        -: 3429:    exception_pop(); \
        -: 3430:    } else { \
        -: 3431:    Obj* var = exception_get_value(); \
        -: 3432:    exception_pop();
        -: 3433:
        -: 3434:#define TRY_END() \
        -: 3435:    } \
        -: 3436:} while(0)
        -: 3437:
        -: 3438:/* Register allocation for cleanup */
        -: 3439:#define REGISTER_CLEANUP(ptr) exception_register_cleanup((void*)(ptr))
        -: 3440:
        -: 3441:/* Unregister after normal free */
        -: 3442:#define UNREGISTER_CLEANUP(ptr) exception_unregister_cleanup((void*)(ptr))
        -: 3443:
        -: 3444:/* Throw macro */
        -: 3445:#define THROW(value) exception_throw((Obj*)(value))
